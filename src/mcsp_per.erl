%% Generated by the Erlang ASN.1 PER (aligned) compiler. Version: 5.0.16
%% Purpose: Encoding and decoding of the types in MCS-PROTOCOL.

-module('mcsp_per').
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-include("mcsp.hrl").
-asn1_info([{vsn,'5.0.16'},
            {module,'MCS-PROTOCOL'},
            {options,[per,noobj,undec_rest,verbose,{i,"."},{i,".."}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_ChannelId/1,
enc_StaticChannelId/1,
enc_DynamicChannelId/1,
enc_UserId/1,
enc_PrivateChannelId/1,
enc_AssignedChannelId/1,
enc_TokenId/1,
enc_TokenStatus/1,
enc_DataPriority/1,
enc_Segmentation/1,
enc_DomainParameters/1,
'enc_Connect-Initial'/1,
'enc_Connect-Response'/1,
'enc_Connect-Additional'/1,
'enc_Connect-Result'/1,
enc_PlumbDomainIndication/1,
enc_ErectDomainRequest/1,
enc_ChannelAttributes/1,
enc_MergeChannelsRequest/1,
enc_MergeChannelsConfirm/1,
enc_PurgeChannelsIndication/1,
enc_TokenAttributes/1,
enc_MergeTokensRequest/1,
enc_MergeTokensConfirm/1,
enc_PurgeTokensIndication/1,
enc_DisconnectProviderUltimatum/1,
enc_RejectMCSPDUUltimatum/1,
enc_AttachUserRequest/1,
enc_AttachUserConfirm/1,
enc_DetachUserRequest/1,
enc_DetachUserIndication/1,
enc_ChannelJoinRequest/1,
enc_ChannelJoinConfirm/1,
enc_ChannelLeaveRequest/1,
enc_ChannelConveneRequest/1,
enc_ChannelConveneConfirm/1,
enc_ChannelDisbandRequest/1,
enc_ChannelDisbandIndication/1,
enc_ChannelAdmitRequest/1,
enc_ChannelAdmitIndication/1,
enc_ChannelExpelRequest/1,
enc_ChannelExpelIndication/1,
enc_SendDataRequest/1,
enc_SendDataIndication/1,
enc_UniformSendDataRequest/1,
enc_UniformSendDataIndication/1,
enc_TokenGrabRequest/1,
enc_TokenGrabConfirm/1,
enc_TokenInhibitRequest/1,
enc_TokenInhibitConfirm/1,
enc_TokenGiveRequest/1,
enc_TokenGiveIndication/1,
enc_TokenGiveResponse/1,
enc_TokenGiveConfirm/1,
enc_TokenPleaseRequest/1,
enc_TokenPleaseIndication/1,
enc_TokenReleaseRequest/1,
enc_TokenReleaseConfirm/1,
enc_TokenTestRequest/1,
enc_TokenTestConfirm/1,
enc_Reason/1,
enc_Result/1,
enc_Diagnostic/1,
enc_ConnectMCSPDU/1,
enc_DomainMCSPDU/1
]).

-export([
dec_ChannelId/1,
dec_StaticChannelId/1,
dec_DynamicChannelId/1,
dec_UserId/1,
dec_PrivateChannelId/1,
dec_AssignedChannelId/1,
dec_TokenId/1,
dec_TokenStatus/1,
dec_DataPriority/1,
dec_Segmentation/1,
dec_DomainParameters/1,
'dec_Connect-Initial'/1,
'dec_Connect-Response'/1,
'dec_Connect-Additional'/1,
'dec_Connect-Result'/1,
dec_PlumbDomainIndication/1,
dec_ErectDomainRequest/1,
dec_ChannelAttributes/1,
dec_MergeChannelsRequest/1,
dec_MergeChannelsConfirm/1,
dec_PurgeChannelsIndication/1,
dec_TokenAttributes/1,
dec_MergeTokensRequest/1,
dec_MergeTokensConfirm/1,
dec_PurgeTokensIndication/1,
dec_DisconnectProviderUltimatum/1,
dec_RejectMCSPDUUltimatum/1,
dec_AttachUserRequest/1,
dec_AttachUserConfirm/1,
dec_DetachUserRequest/1,
dec_DetachUserIndication/1,
dec_ChannelJoinRequest/1,
dec_ChannelJoinConfirm/1,
dec_ChannelLeaveRequest/1,
dec_ChannelConveneRequest/1,
dec_ChannelConveneConfirm/1,
dec_ChannelDisbandRequest/1,
dec_ChannelDisbandIndication/1,
dec_ChannelAdmitRequest/1,
dec_ChannelAdmitIndication/1,
dec_ChannelExpelRequest/1,
dec_ChannelExpelIndication/1,
dec_SendDataRequest/1,
dec_SendDataIndication/1,
dec_UniformSendDataRequest/1,
dec_UniformSendDataIndication/1,
dec_TokenGrabRequest/1,
dec_TokenGrabConfirm/1,
dec_TokenInhibitRequest/1,
dec_TokenInhibitConfirm/1,
dec_TokenGiveRequest/1,
dec_TokenGiveIndication/1,
dec_TokenGiveResponse/1,
dec_TokenGiveConfirm/1,
dec_TokenPleaseRequest/1,
dec_TokenPleaseIndication/1,
dec_TokenReleaseRequest/1,
dec_TokenReleaseConfirm/1,
dec_TokenTestRequest/1,
dec_TokenTestConfirm/1,
dec_Reason/1,
dec_Result/1,
dec_Diagnostic/1,
dec_ConnectMCSPDU/1,
dec_DomainMCSPDU/1
]).

-export([info/0]).

-export([encode/2,decode/2]).

encoding_rule() -> per.

maps() -> false.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try complete(encode_disp(Type, Data)) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

decode(Type, Data) ->
try
   {Result,Rest} = decode_disp(Type, Data),
   {ok,Result,Rest}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('ChannelId', Data) -> enc_ChannelId(Data);
encode_disp('StaticChannelId', Data) -> enc_StaticChannelId(Data);
encode_disp('DynamicChannelId', Data) -> enc_DynamicChannelId(Data);
encode_disp('UserId', Data) -> enc_UserId(Data);
encode_disp('PrivateChannelId', Data) -> enc_PrivateChannelId(Data);
encode_disp('AssignedChannelId', Data) -> enc_AssignedChannelId(Data);
encode_disp('TokenId', Data) -> enc_TokenId(Data);
encode_disp('TokenStatus', Data) -> enc_TokenStatus(Data);
encode_disp('DataPriority', Data) -> enc_DataPriority(Data);
encode_disp('Segmentation', Data) -> enc_Segmentation(Data);
encode_disp('DomainParameters', Data) -> enc_DomainParameters(Data);
encode_disp('Connect-Initial', Data) -> 'enc_Connect-Initial'(Data);
encode_disp('Connect-Response', Data) -> 'enc_Connect-Response'(Data);
encode_disp('Connect-Additional', Data) -> 'enc_Connect-Additional'(Data);
encode_disp('Connect-Result', Data) -> 'enc_Connect-Result'(Data);
encode_disp('PlumbDomainIndication', Data) -> enc_PlumbDomainIndication(Data);
encode_disp('ErectDomainRequest', Data) -> enc_ErectDomainRequest(Data);
encode_disp('ChannelAttributes', Data) -> enc_ChannelAttributes(Data);
encode_disp('MergeChannelsRequest', Data) -> enc_MergeChannelsRequest(Data);
encode_disp('MergeChannelsConfirm', Data) -> enc_MergeChannelsConfirm(Data);
encode_disp('PurgeChannelsIndication', Data) -> enc_PurgeChannelsIndication(Data);
encode_disp('TokenAttributes', Data) -> enc_TokenAttributes(Data);
encode_disp('MergeTokensRequest', Data) -> enc_MergeTokensRequest(Data);
encode_disp('MergeTokensConfirm', Data) -> enc_MergeTokensConfirm(Data);
encode_disp('PurgeTokensIndication', Data) -> enc_PurgeTokensIndication(Data);
encode_disp('DisconnectProviderUltimatum', Data) -> enc_DisconnectProviderUltimatum(Data);
encode_disp('RejectMCSPDUUltimatum', Data) -> enc_RejectMCSPDUUltimatum(Data);
encode_disp('AttachUserRequest', Data) -> enc_AttachUserRequest(Data);
encode_disp('AttachUserConfirm', Data) -> enc_AttachUserConfirm(Data);
encode_disp('DetachUserRequest', Data) -> enc_DetachUserRequest(Data);
encode_disp('DetachUserIndication', Data) -> enc_DetachUserIndication(Data);
encode_disp('ChannelJoinRequest', Data) -> enc_ChannelJoinRequest(Data);
encode_disp('ChannelJoinConfirm', Data) -> enc_ChannelJoinConfirm(Data);
encode_disp('ChannelLeaveRequest', Data) -> enc_ChannelLeaveRequest(Data);
encode_disp('ChannelConveneRequest', Data) -> enc_ChannelConveneRequest(Data);
encode_disp('ChannelConveneConfirm', Data) -> enc_ChannelConveneConfirm(Data);
encode_disp('ChannelDisbandRequest', Data) -> enc_ChannelDisbandRequest(Data);
encode_disp('ChannelDisbandIndication', Data) -> enc_ChannelDisbandIndication(Data);
encode_disp('ChannelAdmitRequest', Data) -> enc_ChannelAdmitRequest(Data);
encode_disp('ChannelAdmitIndication', Data) -> enc_ChannelAdmitIndication(Data);
encode_disp('ChannelExpelRequest', Data) -> enc_ChannelExpelRequest(Data);
encode_disp('ChannelExpelIndication', Data) -> enc_ChannelExpelIndication(Data);
encode_disp('SendDataRequest', Data) -> enc_SendDataRequest(Data);
encode_disp('SendDataIndication', Data) -> enc_SendDataIndication(Data);
encode_disp('UniformSendDataRequest', Data) -> enc_UniformSendDataRequest(Data);
encode_disp('UniformSendDataIndication', Data) -> enc_UniformSendDataIndication(Data);
encode_disp('TokenGrabRequest', Data) -> enc_TokenGrabRequest(Data);
encode_disp('TokenGrabConfirm', Data) -> enc_TokenGrabConfirm(Data);
encode_disp('TokenInhibitRequest', Data) -> enc_TokenInhibitRequest(Data);
encode_disp('TokenInhibitConfirm', Data) -> enc_TokenInhibitConfirm(Data);
encode_disp('TokenGiveRequest', Data) -> enc_TokenGiveRequest(Data);
encode_disp('TokenGiveIndication', Data) -> enc_TokenGiveIndication(Data);
encode_disp('TokenGiveResponse', Data) -> enc_TokenGiveResponse(Data);
encode_disp('TokenGiveConfirm', Data) -> enc_TokenGiveConfirm(Data);
encode_disp('TokenPleaseRequest', Data) -> enc_TokenPleaseRequest(Data);
encode_disp('TokenPleaseIndication', Data) -> enc_TokenPleaseIndication(Data);
encode_disp('TokenReleaseRequest', Data) -> enc_TokenReleaseRequest(Data);
encode_disp('TokenReleaseConfirm', Data) -> enc_TokenReleaseConfirm(Data);
encode_disp('TokenTestRequest', Data) -> enc_TokenTestRequest(Data);
encode_disp('TokenTestConfirm', Data) -> enc_TokenTestConfirm(Data);
encode_disp('Reason', Data) -> enc_Reason(Data);
encode_disp('Result', Data) -> enc_Result(Data);
encode_disp('Diagnostic', Data) -> enc_Diagnostic(Data);
encode_disp('ConnectMCSPDU', Data) -> enc_ConnectMCSPDU(Data);
encode_disp('DomainMCSPDU', Data) -> enc_DomainMCSPDU(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('ChannelId', Data) -> dec_ChannelId(Data);
decode_disp('StaticChannelId', Data) -> dec_StaticChannelId(Data);
decode_disp('DynamicChannelId', Data) -> dec_DynamicChannelId(Data);
decode_disp('UserId', Data) -> dec_UserId(Data);
decode_disp('PrivateChannelId', Data) -> dec_PrivateChannelId(Data);
decode_disp('AssignedChannelId', Data) -> dec_AssignedChannelId(Data);
decode_disp('TokenId', Data) -> dec_TokenId(Data);
decode_disp('TokenStatus', Data) -> dec_TokenStatus(Data);
decode_disp('DataPriority', Data) -> dec_DataPriority(Data);
decode_disp('Segmentation', Data) -> dec_Segmentation(Data);
decode_disp('DomainParameters', Data) -> dec_DomainParameters(Data);
decode_disp('Connect-Initial', Data) -> 'dec_Connect-Initial'(Data);
decode_disp('Connect-Response', Data) -> 'dec_Connect-Response'(Data);
decode_disp('Connect-Additional', Data) -> 'dec_Connect-Additional'(Data);
decode_disp('Connect-Result', Data) -> 'dec_Connect-Result'(Data);
decode_disp('PlumbDomainIndication', Data) -> dec_PlumbDomainIndication(Data);
decode_disp('ErectDomainRequest', Data) -> dec_ErectDomainRequest(Data);
decode_disp('ChannelAttributes', Data) -> dec_ChannelAttributes(Data);
decode_disp('MergeChannelsRequest', Data) -> dec_MergeChannelsRequest(Data);
decode_disp('MergeChannelsConfirm', Data) -> dec_MergeChannelsConfirm(Data);
decode_disp('PurgeChannelsIndication', Data) -> dec_PurgeChannelsIndication(Data);
decode_disp('TokenAttributes', Data) -> dec_TokenAttributes(Data);
decode_disp('MergeTokensRequest', Data) -> dec_MergeTokensRequest(Data);
decode_disp('MergeTokensConfirm', Data) -> dec_MergeTokensConfirm(Data);
decode_disp('PurgeTokensIndication', Data) -> dec_PurgeTokensIndication(Data);
decode_disp('DisconnectProviderUltimatum', Data) -> dec_DisconnectProviderUltimatum(Data);
decode_disp('RejectMCSPDUUltimatum', Data) -> dec_RejectMCSPDUUltimatum(Data);
decode_disp('AttachUserRequest', Data) -> dec_AttachUserRequest(Data);
decode_disp('AttachUserConfirm', Data) -> dec_AttachUserConfirm(Data);
decode_disp('DetachUserRequest', Data) -> dec_DetachUserRequest(Data);
decode_disp('DetachUserIndication', Data) -> dec_DetachUserIndication(Data);
decode_disp('ChannelJoinRequest', Data) -> dec_ChannelJoinRequest(Data);
decode_disp('ChannelJoinConfirm', Data) -> dec_ChannelJoinConfirm(Data);
decode_disp('ChannelLeaveRequest', Data) -> dec_ChannelLeaveRequest(Data);
decode_disp('ChannelConveneRequest', Data) -> dec_ChannelConveneRequest(Data);
decode_disp('ChannelConveneConfirm', Data) -> dec_ChannelConveneConfirm(Data);
decode_disp('ChannelDisbandRequest', Data) -> dec_ChannelDisbandRequest(Data);
decode_disp('ChannelDisbandIndication', Data) -> dec_ChannelDisbandIndication(Data);
decode_disp('ChannelAdmitRequest', Data) -> dec_ChannelAdmitRequest(Data);
decode_disp('ChannelAdmitIndication', Data) -> dec_ChannelAdmitIndication(Data);
decode_disp('ChannelExpelRequest', Data) -> dec_ChannelExpelRequest(Data);
decode_disp('ChannelExpelIndication', Data) -> dec_ChannelExpelIndication(Data);
decode_disp('SendDataRequest', Data) -> dec_SendDataRequest(Data);
decode_disp('SendDataIndication', Data) -> dec_SendDataIndication(Data);
decode_disp('UniformSendDataRequest', Data) -> dec_UniformSendDataRequest(Data);
decode_disp('UniformSendDataIndication', Data) -> dec_UniformSendDataIndication(Data);
decode_disp('TokenGrabRequest', Data) -> dec_TokenGrabRequest(Data);
decode_disp('TokenGrabConfirm', Data) -> dec_TokenGrabConfirm(Data);
decode_disp('TokenInhibitRequest', Data) -> dec_TokenInhibitRequest(Data);
decode_disp('TokenInhibitConfirm', Data) -> dec_TokenInhibitConfirm(Data);
decode_disp('TokenGiveRequest', Data) -> dec_TokenGiveRequest(Data);
decode_disp('TokenGiveIndication', Data) -> dec_TokenGiveIndication(Data);
decode_disp('TokenGiveResponse', Data) -> dec_TokenGiveResponse(Data);
decode_disp('TokenGiveConfirm', Data) -> dec_TokenGiveConfirm(Data);
decode_disp('TokenPleaseRequest', Data) -> dec_TokenPleaseRequest(Data);
decode_disp('TokenPleaseIndication', Data) -> dec_TokenPleaseIndication(Data);
decode_disp('TokenReleaseRequest', Data) -> dec_TokenReleaseRequest(Data);
decode_disp('TokenReleaseConfirm', Data) -> dec_TokenReleaseConfirm(Data);
decode_disp('TokenTestRequest', Data) -> dec_TokenTestRequest(Data);
decode_disp('TokenTestConfirm', Data) -> dec_TokenTestConfirm(Data);
decode_disp('Reason', Data) -> dec_Reason(Data);
decode_disp('Result', Data) -> dec_Result(Data);
decode_disp('Diagnostic', Data) -> dec_Diagnostic(Data);
decode_disp('ConnectMCSPDU', Data) -> dec_ConnectMCSPDU(Data);
decode_disp('DomainMCSPDU', Data) -> dec_DomainMCSPDU(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.
enc_ChannelId(Val) ->
if Val bsr 16 =:= 0 ->
[align|<<Val:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_ChannelId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_StaticChannelId(Val) ->
if Val bsr 16 =:= 0 ->
[align|<<Val:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_StaticChannelId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_DynamicChannelId(Val) ->
if Val bsr 16 =:= 0 ->
[align|<<Val:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_DynamicChannelId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_UserId(Val) ->
if Val bsr 16 =:= 0 ->
[align|<<Val:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_UserId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_PrivateChannelId(Val) ->
if Val bsr 16 =:= 0 ->
[align|<<Val:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_PrivateChannelId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_AssignedChannelId(Val) ->
if Val bsr 16 =:= 0 ->
[align|<<Val:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_AssignedChannelId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end.

enc_TokenId(Val) ->
Val@sub = Val - 1,
if 0 =< Val@sub, Val@sub < 65535 ->
[align|<<Val@sub:16>>];
true ->
exit({error,{asn1,{illegal_integer,Val}}})
end.


dec_TokenId(Bytes) ->
begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end.

enc_TokenStatus(Val) ->
if Val =:= notInUse ->
<<0:3>>;
Val =:= selfGrabbed ->
<<1:3>>;
Val =:= otherGrabbed ->
<<2:3>>;
Val =:= selfInhibited ->
<<3:3>>;
Val =:= otherInhibited ->
<<4:3>>;
Val =:= selfRecipient ->
<<5:3>>;
Val =:= selfGiving ->
<<6:3>>;
Val =:= otherGiving ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_TokenStatus(Bytes) ->
begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> notInUse;
1 -> selfGrabbed;
2 -> otherGrabbed;
3 -> selfInhibited;
4 -> otherInhibited;
5 -> selfRecipient;
6 -> selfGiving;
7 -> otherGiving
end,
{V1@Int2,V1@Buf1}
end.

enc_DataPriority(Val) ->
if Val =:= top ->
<<0:2>>;
Val =:= high ->
<<1:2>>;
Val =:= medium ->
<<2:2>>;
Val =:= low ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_DataPriority(Bytes) ->
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> top;
1 -> high;
2 -> medium;
3 -> low
end,
{V1@Int2,V1@Buf1}
end.

enc_Segmentation(Val) ->
Enc1@bs = try bit_string_name2pos_1(Val) of
Enc1@positions ->
bitstring_from_positions(Enc1@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Val, 2)
end,
Enc1@bits = bit_size(Enc1@bs),
if Enc1@bits =:= 2 ->
Enc1@bs
end.


dec_Segmentation(Bytes) ->
begin
<<V1@V0:2/binary-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V2,V1@Buf3}  = {decode_named_bit_string(V1@V0, [{'begin',0},{'end',1}]),V1@Buf1},
{V1@V2,V1@Buf3}
end.

enc_DomainParameters(Val) ->
[align,
begin
%% attribute maxChannelIds(1) with type INTEGER
Enc1@element = element(2, Val),
encode_unconstrained_number(Enc1@element)
end,
begin
%% attribute maxUserIds(2) with type INTEGER
Enc3@element = element(3, Val),
encode_unconstrained_number(Enc3@element)
end,
begin
%% attribute maxTokenIds(3) with type INTEGER
Enc5@element = element(4, Val),
encode_unconstrained_number(Enc5@element)
end,
begin
%% attribute numPriorities(4) with type INTEGER
Enc7@element = element(5, Val),
encode_unconstrained_number(Enc7@element)
end,
begin
%% attribute minThroughput(5) with type INTEGER
Enc9@element = element(6, Val),
encode_unconstrained_number(Enc9@element)
end,
begin
%% attribute maxHeight(6) with type INTEGER
Enc11@element = element(7, Val),
encode_unconstrained_number(Enc11@element)
end,
begin
%% attribute maxMCSPDUsize(7) with type INTEGER
Enc13@element = element(8, Val),
encode_unconstrained_number(Enc13@element)
end|begin
%% attribute protocolVersion(8) with type INTEGER
Enc15@element = element(9, Val),
encode_unconstrained_number(Enc15@element)
end].


dec_DomainParameters(Bytes) ->

%% attribute maxChannelIds(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/signed-unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end,

%% attribute maxUserIds(2) with type INTEGER
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@Buf4/bitstring>> when V2@V3 =/= 0 ->
{V2@V3,V2@Buf4};
<<1:1,0:1,V2@V4:14,V2@Buf5/bitstring>> when V2@V4 =/= 0 ->
{V2@V4,V2@Buf5}
end,
<<V2@V6:V2@V0/signed-unit:8,V2@Buf7/bitstring>> = V2@Buf1,
{V2@V6,V2@Buf7}
end,

%% attribute maxTokenIds(3) with type INTEGER
{Term3,Bytes3} = begin
{V3@V0,V3@Buf1} = case Bytes2 of
<<0:1,V3@V3:7,V3@Buf4/bitstring>> when V3@V3 =/= 0 ->
{V3@V3,V3@Buf4};
<<1:1,0:1,V3@V4:14,V3@Buf5/bitstring>> when V3@V4 =/= 0 ->
{V3@V4,V3@Buf5}
end,
<<V3@V6:V3@V0/signed-unit:8,V3@Buf7/bitstring>> = V3@Buf1,
{V3@V6,V3@Buf7}
end,

%% attribute numPriorities(4) with type INTEGER
{Term4,Bytes4} = begin
{V4@V0,V4@Buf1} = case Bytes3 of
<<0:1,V4@V3:7,V4@Buf4/bitstring>> when V4@V3 =/= 0 ->
{V4@V3,V4@Buf4};
<<1:1,0:1,V4@V4:14,V4@Buf5/bitstring>> when V4@V4 =/= 0 ->
{V4@V4,V4@Buf5}
end,
<<V4@V6:V4@V0/signed-unit:8,V4@Buf7/bitstring>> = V4@Buf1,
{V4@V6,V4@Buf7}
end,

%% attribute minThroughput(5) with type INTEGER
{Term5,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<0:1,V5@V3:7,V5@Buf4/bitstring>> when V5@V3 =/= 0 ->
{V5@V3,V5@Buf4};
<<1:1,0:1,V5@V4:14,V5@Buf5/bitstring>> when V5@V4 =/= 0 ->
{V5@V4,V5@Buf5}
end,
<<V5@V6:V5@V0/signed-unit:8,V5@Buf7/bitstring>> = V5@Buf1,
{V5@V6,V5@Buf7}
end,

%% attribute maxHeight(6) with type INTEGER
{Term6,Bytes6} = begin
{V6@V0,V6@Buf1} = case Bytes5 of
<<0:1,V6@V3:7,V6@Buf4/bitstring>> when V6@V3 =/= 0 ->
{V6@V3,V6@Buf4};
<<1:1,0:1,V6@V4:14,V6@Buf5/bitstring>> when V6@V4 =/= 0 ->
{V6@V4,V6@Buf5}
end,
<<V6@V6:V6@V0/signed-unit:8,V6@Buf7/bitstring>> = V6@Buf1,
{V6@V6,V6@Buf7}
end,

%% attribute maxMCSPDUsize(7) with type INTEGER
{Term7,Bytes7} = begin
{V7@V0,V7@Buf1} = case Bytes6 of
<<0:1,V7@V3:7,V7@Buf4/bitstring>> when V7@V3 =/= 0 ->
{V7@V3,V7@Buf4};
<<1:1,0:1,V7@V4:14,V7@Buf5/bitstring>> when V7@V4 =/= 0 ->
{V7@V4,V7@Buf5}
end,
<<V7@V6:V7@V0/signed-unit:8,V7@Buf7/bitstring>> = V7@Buf1,
{V7@V6,V7@Buf7}
end,

%% attribute protocolVersion(8) with type INTEGER
{Term8,Bytes8} = begin
{V8@V0,V8@Buf1} = case Bytes7 of
<<0:1,V8@V3:7,V8@Buf4/bitstring>> when V8@V3 =/= 0 ->
{V8@V3,V8@Buf4};
<<1:1,0:1,V8@V4:14,V8@Buf5/bitstring>> when V8@V4 =/= 0 ->
{V8@V4,V8@Buf5}
end,
<<V8@V6:V8@V0/signed-unit:8,V8@Buf7/bitstring>> = V8@Buf1,
{V8@V6,V8@Buf7}
end,
Res1 = {'DomainParameters',Term1,Term2,Term3,Term4,Term5,Term6,Term7,Term8},
{Res1,Bytes8}.

'enc_Connect-Initial'(Val) ->
[align,
begin
%% attribute callingDomainSelector(1) with type OCTET STRING
Enc1@element = element(2, Val),
Enc2@len = byte_size(Enc1@element),
if Enc2@len < 128 ->
[Enc2@len|Enc1@element];
Enc2@len < 16384 ->
[<<2:2,Enc2@len:14>>|Enc1@element];
true ->
encode_fragmented(Enc1@element, 8)
end
end,
begin
%% attribute calledDomainSelector(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end,
begin
%% attribute upwardFlag(3) with type BOOLEAN
Enc5@element = element(4, Val),
if Enc5@element =:= false ->
<<0:1>>;
Enc5@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc5@element}}})
end
end,
begin
%% attribute targetParameters(4) with type DomainParameters
Enc7@element = element(5, Val),
enc_DomainParameters(Enc7@element)
end,
begin
%% attribute minimumParameters(5) with type DomainParameters
Enc8@element = element(6, Val),
enc_DomainParameters(Enc8@element)
end,
begin
%% attribute maximumParameters(6) with type DomainParameters
Enc9@element = element(7, Val),
enc_DomainParameters(Enc9@element)
end,
align|begin
%% attribute userData(7) with type OCTET STRING
Enc10@element = element(8, Val),
Enc11@len = byte_size(Enc10@element),
if Enc11@len < 128 ->
[Enc11@len|Enc10@element];
Enc11@len < 16384 ->
[<<2:2,Enc11@len:14>>|Enc10@element];
true ->
encode_fragmented(Enc10@element, 8)
end
end].


'dec_Connect-Initial'(Bytes) ->

%% attribute callingDomainSelector(1) with type OCTET STRING
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@V7:V1@V5/binary-unit:8,V1@Buf8/bitstring>> ->
{V1@V7,V1@Buf8};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@V8:V1@V6/binary-unit:8,V1@Buf9/bitstring>> ->
{V1@V8,V1@Buf9};
<<_:V1@Pad3,1:1,1:1,V1@V6:6,V1@Buf7/bitstring>> ->
{V1@V8,V1@Buf9}  = decode_fragmented(V1@V6, V1@Buf7, 8),
{V1@V8,V1@Buf9}
end,
V1@Conv10 = binary:copy(V1@V0),
{V1@Conv10,V1@Buf1}
end,

%% attribute calledDomainSelector(2) with type OCTET STRING
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@V5:V2@V3/binary-unit:8,V2@Buf6/bitstring>> ->
{V2@V5,V2@Buf6};
<<1:1,0:1,V2@V4:14,V2@V6:V2@V4/binary-unit:8,V2@Buf7/bitstring>> ->
{V2@V6,V2@Buf7};
<<1:1,1:1,V2@V4:6,V2@Buf5/bitstring>> ->
{V2@V6,V2@Buf7}  = decode_fragmented(V2@V4, V2@Buf5, 8),
{V2@V6,V2@Buf7}
end,
V2@Conv8 = binary:copy(V2@V0),
{V2@Conv8,V2@Buf1}
end,

%% attribute upwardFlag(3) with type BOOLEAN
{Term3,Bytes3} = begin
<<V3@V0:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> false;
1 -> true
end,
{V3@Int2,V3@Buf1}
end,

%% attribute targetParameters(4) with type DomainParameters
{Term4,Bytes4} = dec_DomainParameters(Bytes3),

%% attribute minimumParameters(5) with type DomainParameters
{Term5,Bytes5} = dec_DomainParameters(Bytes4),

%% attribute maximumParameters(6) with type DomainParameters
{Term6,Bytes6} = dec_DomainParameters(Bytes5),

%% attribute userData(7) with type OCTET STRING
{Term7,Bytes7} = begin
V4@Pad3 = bit_size(Bytes6) band 7,
{V4@V0,V4@Buf1} = case Bytes6 of
<<_:V4@Pad3,0:1,V4@V5:7,V4@V7:V4@V5/binary-unit:8,V4@Buf8/bitstring>> ->
{V4@V7,V4@Buf8};
<<_:V4@Pad3,1:1,0:1,V4@V6:14,V4@V8:V4@V6/binary-unit:8,V4@Buf9/bitstring>> ->
{V4@V8,V4@Buf9};
<<_:V4@Pad3,1:1,1:1,V4@V6:6,V4@Buf7/bitstring>> ->
{V4@V8,V4@Buf9}  = decode_fragmented(V4@V6, V4@Buf7, 8),
{V4@V8,V4@Buf9}
end,
V4@Conv10 = binary:copy(V4@V0),
{V4@Conv10,V4@Buf1}
end,
Res1 = {'Connect-Initial',Term1,Term2,Term3,Term4,Term5,Term6,Term7},
{Res1,Bytes7}.

'enc_Connect-Response'(Val) ->
[begin
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align,
begin
%% attribute calledConnectId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element >= 0 ->
begin
Enc3@element@bin = binary:encode_unsigned(Enc3@element),
Enc3@element@bin_size = byte_size(Enc3@element@bin),
if Enc3@element@bin_size < 128 ->
[Enc3@element@bin_size|Enc3@element@bin];
Enc3@element@bin_size < 16384 ->
[<<2:2,Enc3@element@bin_size:14>>|Enc3@element@bin];
true ->
encode_fragmented(Enc3@element@bin, 8)
end
end;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute domainParameters(3) with type DomainParameters
Enc5@element = element(4, Val),
enc_DomainParameters(Enc5@element)
end,
align|begin
%% attribute userData(4) with type OCTET STRING
Enc6@element = element(5, Val),
Enc7@len = byte_size(Enc6@element),
if Enc7@len < 128 ->
[Enc7@len|Enc6@element];
Enc7@len < 16384 ->
[<<2:2,Enc7@len:14>>|Enc6@element];
true ->
encode_fragmented(Enc6@element, 8)
end
end].


'dec_Connect-Response'(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute calledConnectId(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad3 = bit_size(Bytes1) band 7,
{V2@V0,V2@Buf1} = case Bytes1 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@Buf6/bitstring>> when V2@V5 =/= 0 ->
{V2@V5,V2@Buf6};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@Buf7/bitstring>> when V2@V6 =/= 0 ->
{V2@V6,V2@Buf7}
end,
<<V2@V8:V2@V0/unit:8,V2@Buf9/bitstring>> = V2@Buf1,
{V2@V8,V2@Buf9}
end,

%% attribute domainParameters(3) with type DomainParameters
{Term3,Bytes3} = dec_DomainParameters(Bytes2),

%% attribute userData(4) with type OCTET STRING
{Term4,Bytes4} = begin
V3@Pad3 = bit_size(Bytes3) band 7,
{V3@V0,V3@Buf1} = case Bytes3 of
<<_:V3@Pad3,0:1,V3@V5:7,V3@V7:V3@V5/binary-unit:8,V3@Buf8/bitstring>> ->
{V3@V7,V3@Buf8};
<<_:V3@Pad3,1:1,0:1,V3@V6:14,V3@V8:V3@V6/binary-unit:8,V3@Buf9/bitstring>> ->
{V3@V8,V3@Buf9};
<<_:V3@Pad3,1:1,1:1,V3@V6:6,V3@Buf7/bitstring>> ->
{V3@V8,V3@Buf9}  = decode_fragmented(V3@V6, V3@Buf7, 8),
{V3@V8,V3@Buf9}
end,
V3@Conv10 = binary:copy(V3@V0),
{V3@Conv10,V3@Buf1}
end,
Res1 = {'Connect-Response',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

'enc_Connect-Additional'(Val) ->
[align,
begin
%% attribute calledConnectId(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element >= 0 ->
begin
Enc1@element@bin = binary:encode_unsigned(Enc1@element),
Enc1@element@bin_size = byte_size(Enc1@element@bin),
if Enc1@element@bin_size < 128 ->
[Enc1@element@bin_size|Enc1@element@bin];
Enc1@element@bin_size < 16384 ->
[<<2:2,Enc1@element@bin_size:14>>|Enc1@element@bin];
true ->
encode_fragmented(Enc1@element@bin, 8)
end
end;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute dataPriority(2) with type ENUMERATED
Enc3@element = element(3, Val),
if Enc3@element =:= top ->
<<0:2>>;
Enc3@element =:= high ->
<<1:2>>;
Enc3@element =:= medium ->
<<2:2>>;
Enc3@element =:= low ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc3@element}}})
end
end].


'dec_Connect-Additional'(Bytes) ->

%% attribute calledConnectId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end,

%% attribute dataPriority(2) with type ENUMERATED
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> top;
1 -> high;
2 -> medium;
3 -> low
end,
{V2@Int2,V2@Buf1}
end,
Res1 = {'Connect-Additional',Term1,Term2},
{Res1,Bytes2}.

'enc_Connect-Result'(Val) ->
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end.


'dec_Connect-Result'(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,
Res1 = {'Connect-Result',Term1},
{Res1,Bytes1}.

enc_PlumbDomainIndication(Val) ->
[align|begin
%% attribute heightLimit(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element >= 0 ->
begin
Enc1@element@bin = binary:encode_unsigned(Enc1@element),
Enc1@element@bin_size = byte_size(Enc1@element@bin),
if Enc1@element@bin_size < 128 ->
[Enc1@element@bin_size|Enc1@element@bin];
Enc1@element@bin_size < 16384 ->
[<<2:2,Enc1@element@bin_size:14>>|Enc1@element@bin];
true ->
encode_fragmented(Enc1@element@bin, 8)
end
end;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end].


dec_PlumbDomainIndication(Bytes) ->

%% attribute heightLimit(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end,
Res1 = {'PlumbDomainIndication',Term1},
{Res1,Bytes1}.

enc_ErectDomainRequest(Val) ->
[align,
begin
%% attribute subHeight(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element >= 0 ->
begin
Enc1@element@bin = binary:encode_unsigned(Enc1@element),
Enc1@element@bin_size = byte_size(Enc1@element@bin),
if Enc1@element@bin_size < 128 ->
[Enc1@element@bin_size|Enc1@element@bin];
Enc1@element@bin_size < 16384 ->
[<<2:2,Enc1@element@bin_size:14>>|Enc1@element@bin];
true ->
encode_fragmented(Enc1@element@bin, 8)
end
end;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute subInterval(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element >= 0 ->
begin
Enc3@element@bin = binary:encode_unsigned(Enc3@element),
Enc3@element@bin_size = byte_size(Enc3@element@bin),
if Enc3@element@bin_size < 128 ->
[Enc3@element@bin_size|Enc3@element@bin];
Enc3@element@bin_size < 16384 ->
[<<2:2,Enc3@element@bin_size:14>>|Enc3@element@bin];
true ->
encode_fragmented(Enc3@element@bin, 8)
end
end;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_ErectDomainRequest(Bytes) ->

%% attribute subHeight(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> when V1@V5 =/= 0 ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> when V1@V6 =/= 0 ->
{V1@V6,V1@Buf7}
end,
<<V1@V8:V1@V0/unit:8,V1@Buf9/bitstring>> = V1@Buf1,
{V1@V8,V1@Buf9}
end,

%% attribute subInterval(2) with type INTEGER
{Term2,Bytes2} = begin
{V2@V0,V2@Buf1} = case Bytes1 of
<<0:1,V2@V3:7,V2@Buf4/bitstring>> when V2@V3 =/= 0 ->
{V2@V3,V2@Buf4};
<<1:1,0:1,V2@V4:14,V2@Buf5/bitstring>> when V2@V4 =/= 0 ->
{V2@V4,V2@Buf5}
end,
<<V2@V6:V2@V0/unit:8,V2@Buf7/bitstring>> = V2@Buf1,
{V2@V6,V2@Buf7}
end,
Res1 = {'ErectDomainRequest',Term1,Term2},
{Res1,Bytes2}.

enc_ChannelAttributes(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= static ->
[<<0:2>>|enc_ChannelAttributes_static(ChoiceVal)];
ChoiceTag =:= userId ->
[<<1:2>>|enc_ChannelAttributes_userId(ChoiceVal)];
ChoiceTag =:= private ->
[<<2:2>>|enc_ChannelAttributes_private(ChoiceVal)];
ChoiceTag =:= assigned ->
[<<3:2>>|enc_ChannelAttributes_assigned(ChoiceVal)]
end.
enc_ChannelAttributes_static(Val) ->
[align|begin
%% attribute channelId(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end].
enc_ChannelAttributes_userId(Val) ->
[begin
%% attribute joined(1) with type BOOLEAN
Enc1@element = element(2, Val),
if Enc1@element =:= false ->
<<0:1>>;
Enc1@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc1@element}}})
end
end,
align|begin
%% attribute userId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].
enc_ChannelAttributes_private(Val) ->
[begin
%% attribute joined(1) with type BOOLEAN
Enc1@element = element(2, Val),
if Enc1@element =:= false ->
<<0:1>>;
Enc1@element =:= true ->
<<1:1>>;
true ->
exit({error,{asn1,{illegal_boolean,Enc1@element}}})
end
end,
align,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute manager(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute admitted(4) with type SET OF
Enc7@element = element(5, Val),
enc_ChannelAttributes_private_admitted(Enc7@element)
end].
enc_ChannelAttributes_private_admitted(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].

enc_ChannelAttributes_assigned(Val) ->
[align|begin
%% attribute channelId(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end].


dec_ChannelAttributes(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_ChannelAttributes_static(Bytes1)
end,
{{static,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_ChannelAttributes_userId(Bytes1)
end,
{{userId,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_ChannelAttributes_private(Bytes1)
end,
{{private,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_ChannelAttributes_assigned(Bytes1)
end,
{{assigned,Val},NewBytes}
end.

dec_ChannelAttributes_static(Bytes) ->

%% attribute channelId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
Res1 = {'ChannelAttributes_static',Term1},
{Res1,Bytes1}.


dec_ChannelAttributes_userId(Bytes) ->

%% attribute joined(1) with type BOOLEAN
{Term1,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end,

%% attribute userId(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'ChannelAttributes_userId',Term1,Term2},
{Res1,Bytes2}.


dec_ChannelAttributes_private(Bytes) ->

%% attribute joined(1) with type BOOLEAN
{Term1,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> false;
1 -> true
end,
{V1@Int2,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute manager(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute admitted(4) with type SET OF
{Term4,Bytes4} = dec_ChannelAttributes_private_admitted(Bytes3),
Res1 = {'ChannelAttributes_private',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.


dec_ChannelAttributes_private_admitted(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components2(V1@V0, V1@Buf1, []).


dec_ChannelAttributes_assigned(Bytes) ->

%% attribute channelId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
Res1 = {'ChannelAttributes_assigned',Term1},
{Res1,Bytes1}.

enc_MergeChannelsRequest(Val) ->
[begin
%% attribute mergeChannels(1) with type SET OF
Enc1@element = element(2, Val),
enc_MergeChannelsRequest_mergeChannels(Enc1@element)
end|begin
%% attribute purgeChannelIds(2) with type SET OF
Enc2@element = element(3, Val),
enc_MergeChannelsRequest_purgeChannelIds(Enc2@element)
end].
enc_MergeChannelsRequest_mergeChannels(Val) ->
Enc1@len = length(Val),
[if Enc1@len < 128 ->
[align,
Enc1@len];
Enc1@len < 16384 ->
[align|<<2:2,Enc1@len:14>>]
end|[enc_ChannelAttributes(Comp) || Comp <- Val]].

enc_MergeChannelsRequest_purgeChannelIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_MergeChannelsRequest(Bytes) ->

%% attribute mergeChannels(1) with type SET OF
{Term1,Bytes1} = dec_MergeChannelsRequest_mergeChannels(Bytes),

%% attribute purgeChannelIds(2) with type SET OF
{Term2,Bytes2} = dec_MergeChannelsRequest_purgeChannelIds(Bytes1),
Res1 = {'MergeChannelsRequest',Term1,Term2},
{Res1,Bytes2}.


dec_MergeChannelsRequest_mergeChannels(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components3(V1@V0, V1@Buf1, []).


dec_MergeChannelsRequest_purgeChannelIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components4(V1@V0, V1@Buf1, []).

enc_MergeChannelsConfirm(Val) ->
[begin
%% attribute mergeChannels(1) with type SET OF
Enc1@element = element(2, Val),
enc_MergeChannelsConfirm_mergeChannels(Enc1@element)
end|begin
%% attribute purgeChannelIds(2) with type SET OF
Enc2@element = element(3, Val),
enc_MergeChannelsConfirm_purgeChannelIds(Enc2@element)
end].
enc_MergeChannelsConfirm_mergeChannels(Val) ->
Enc1@len = length(Val),
[if Enc1@len < 128 ->
[align,
Enc1@len];
Enc1@len < 16384 ->
[align|<<2:2,Enc1@len:14>>]
end|[enc_ChannelAttributes(Comp) || Comp <- Val]].

enc_MergeChannelsConfirm_purgeChannelIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_MergeChannelsConfirm(Bytes) ->

%% attribute mergeChannels(1) with type SET OF
{Term1,Bytes1} = dec_MergeChannelsConfirm_mergeChannels(Bytes),

%% attribute purgeChannelIds(2) with type SET OF
{Term2,Bytes2} = dec_MergeChannelsConfirm_purgeChannelIds(Bytes1),
Res1 = {'MergeChannelsConfirm',Term1,Term2},
{Res1,Bytes2}.


dec_MergeChannelsConfirm_mergeChannels(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components5(V1@V0, V1@Buf1, []).


dec_MergeChannelsConfirm_purgeChannelIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components6(V1@V0, V1@Buf1, []).

enc_PurgeChannelsIndication(Val) ->
[begin
%% attribute detachUserIds(1) with type SET OF
Enc1@element = element(2, Val),
enc_PurgeChannelsIndication_detachUserIds(Enc1@element)
end|begin
%% attribute purgeChannelIds(2) with type SET OF
Enc2@element = element(3, Val),
enc_PurgeChannelsIndication_purgeChannelIds(Enc2@element)
end].
enc_PurgeChannelsIndication_detachUserIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].

enc_PurgeChannelsIndication_purgeChannelIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_PurgeChannelsIndication(Bytes) ->

%% attribute detachUserIds(1) with type SET OF
{Term1,Bytes1} = dec_PurgeChannelsIndication_detachUserIds(Bytes),

%% attribute purgeChannelIds(2) with type SET OF
{Term2,Bytes2} = dec_PurgeChannelsIndication_purgeChannelIds(Bytes1),
Res1 = {'PurgeChannelsIndication',Term1,Term2},
{Res1,Bytes2}.


dec_PurgeChannelsIndication_detachUserIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components7(V1@V0, V1@Buf1, []).


dec_PurgeChannelsIndication_purgeChannelIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components8(V1@V0, V1@Buf1, []).

enc_TokenAttributes(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= grabbed ->
[<<0:3>>|enc_TokenAttributes_grabbed(ChoiceVal)];
ChoiceTag =:= inhibited ->
[<<1:3>>|enc_TokenAttributes_inhibited(ChoiceVal)];
ChoiceTag =:= giving ->
[<<2:3>>|enc_TokenAttributes_giving(ChoiceVal)];
ChoiceTag =:= ungivable ->
[<<3:3>>|enc_TokenAttributes_ungivable(ChoiceVal)];
ChoiceTag =:= given ->
[<<4:3>>|enc_TokenAttributes_given(ChoiceVal)]
end.
enc_TokenAttributes_grabbed(Val) ->
[align,
begin
%% attribute tokenId(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute grabber(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].
enc_TokenAttributes_inhibited(Val) ->
[align,
begin
%% attribute tokenId(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute inhibitors(2) with type SET OF
Enc3@element = element(3, Val),
enc_TokenAttributes_inhibited_inhibitors(Enc3@element)
end].
enc_TokenAttributes_inhibited_inhibitors(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].

enc_TokenAttributes_giving(Val) ->
[align,
begin
%% attribute tokenId(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute grabber(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute recipient(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].
enc_TokenAttributes_ungivable(Val) ->
[align,
begin
%% attribute tokenId(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute grabber(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].
enc_TokenAttributes_given(Val) ->
[align,
begin
%% attribute tokenId(1) with type INTEGER
Enc1@element = element(2, Val),
Enc1@element@sub = Enc1@element - 1,
if 0 =< Enc1@element@sub, Enc1@element@sub < 65535 ->
<<Enc1@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute recipient(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenAttributes(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_TokenAttributes_grabbed(Bytes1)
end,
{{grabbed,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_TokenAttributes_inhibited(Bytes1)
end,
{{inhibited,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_TokenAttributes_giving(Bytes1)
end,
{{giving,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_TokenAttributes_ungivable(Bytes1)
end,
{{ungivable,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
dec_TokenAttributes_given(Bytes1)
end,
{{given,Val},NewBytes}
end.

dec_TokenAttributes_grabbed(Bytes) ->

%% attribute tokenId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end,

%% attribute grabber(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'TokenAttributes_grabbed',Term1,Term2},
{Res1,Bytes2}.


dec_TokenAttributes_inhibited(Bytes) ->

%% attribute tokenId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end,

%% attribute inhibitors(2) with type SET OF
{Term2,Bytes2} = dec_TokenAttributes_inhibited_inhibitors(Bytes1),
Res1 = {'TokenAttributes_inhibited',Term1,Term2},
{Res1,Bytes2}.


dec_TokenAttributes_inhibited_inhibitors(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components9(V1@V0, V1@Buf1, []).


dec_TokenAttributes_giving(Bytes) ->

%% attribute tokenId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end,

%% attribute grabber(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute recipient(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'TokenAttributes_giving',Term1,Term2,Term3},
{Res1,Bytes3}.


dec_TokenAttributes_ungivable(Bytes) ->

%% attribute tokenId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end,

%% attribute grabber(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'TokenAttributes_ungivable',Term1,Term2},
{Res1,Bytes2}.


dec_TokenAttributes_given(Bytes) ->

%% attribute tokenId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end,

%% attribute recipient(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'TokenAttributes_given',Term1,Term2},
{Res1,Bytes2}.

enc_MergeTokensRequest(Val) ->
[begin
%% attribute mergeTokens(1) with type SET OF
Enc1@element = element(2, Val),
enc_MergeTokensRequest_mergeTokens(Enc1@element)
end|begin
%% attribute purgeTokenIds(2) with type SET OF
Enc2@element = element(3, Val),
enc_MergeTokensRequest_purgeTokenIds(Enc2@element)
end].
enc_MergeTokensRequest_mergeTokens(Val) ->
Enc1@len = length(Val),
[if Enc1@len < 128 ->
[align,
Enc1@len];
Enc1@len < 16384 ->
[align|<<2:2,Enc1@len:14>>]
end|[enc_TokenAttributes(Comp) || Comp <- Val]].

enc_MergeTokensRequest_purgeTokenIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[begin
Comp@sub = Comp - 1,
if 0 =< Comp@sub, Comp@sub < 65535 ->
<<Comp@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end
end || Comp <- Val]].



dec_MergeTokensRequest(Bytes) ->

%% attribute mergeTokens(1) with type SET OF
{Term1,Bytes1} = dec_MergeTokensRequest_mergeTokens(Bytes),

%% attribute purgeTokenIds(2) with type SET OF
{Term2,Bytes2} = dec_MergeTokensRequest_purgeTokenIds(Bytes1),
Res1 = {'MergeTokensRequest',Term1,Term2},
{Res1,Bytes2}.


dec_MergeTokensRequest_mergeTokens(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components10(V1@V0, V1@Buf1, []).


dec_MergeTokensRequest_purgeTokenIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components11(V1@V0, V1@Buf1, []).

enc_MergeTokensConfirm(Val) ->
[begin
%% attribute mergeTokens(1) with type SET OF
Enc1@element = element(2, Val),
enc_MergeTokensConfirm_mergeTokens(Enc1@element)
end|begin
%% attribute purgeTokenIds(2) with type SET OF
Enc2@element = element(3, Val),
enc_MergeTokensConfirm_purgeTokenIds(Enc2@element)
end].
enc_MergeTokensConfirm_mergeTokens(Val) ->
Enc1@len = length(Val),
[if Enc1@len < 128 ->
[align,
Enc1@len];
Enc1@len < 16384 ->
[align|<<2:2,Enc1@len:14>>]
end|[enc_TokenAttributes(Comp) || Comp <- Val]].

enc_MergeTokensConfirm_purgeTokenIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[begin
Comp@sub = Comp - 1,
if 0 =< Comp@sub, Comp@sub < 65535 ->
<<Comp@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end
end || Comp <- Val]].



dec_MergeTokensConfirm(Bytes) ->

%% attribute mergeTokens(1) with type SET OF
{Term1,Bytes1} = dec_MergeTokensConfirm_mergeTokens(Bytes),

%% attribute purgeTokenIds(2) with type SET OF
{Term2,Bytes2} = dec_MergeTokensConfirm_purgeTokenIds(Bytes1),
Res1 = {'MergeTokensConfirm',Term1,Term2},
{Res1,Bytes2}.


dec_MergeTokensConfirm_mergeTokens(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components12(V1@V0, V1@Buf1, []).


dec_MergeTokensConfirm_purgeTokenIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components13(V1@V0, V1@Buf1, []).

enc_PurgeTokensIndication(Val) ->
%% attribute purgeTokenIds(1) with type SET OF
Enc1@element = element(2, Val),
enc_PurgeTokensIndication_purgeTokenIds(Enc1@element).
enc_PurgeTokensIndication_purgeTokenIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[begin
Comp@sub = Comp - 1,
if 0 =< Comp@sub, Comp@sub < 65535 ->
<<Comp@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end
end || Comp <- Val]].



dec_PurgeTokensIndication(Bytes) ->

%% attribute purgeTokenIds(1) with type SET OF
{Term1,Bytes1} = dec_PurgeTokensIndication_purgeTokenIds(Bytes),
Res1 = {'PurgeTokensIndication',Term1},
{Res1,Bytes1}.


dec_PurgeTokensIndication_purgeTokenIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components14(V1@V0, V1@Buf1, []).

enc_DisconnectProviderUltimatum(Val) ->
%% attribute reason(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rn-domain-disconnected' ->
<<0:3>>;
Enc1@element =:= 'rn-provider-initiated' ->
<<1:3>>;
Enc1@element =:= 'rn-token-purged' ->
<<2:3>>;
Enc1@element =:= 'rn-user-requested' ->
<<3:3>>;
Enc1@element =:= 'rn-channel-purged' ->
<<4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end.


dec_DisconnectProviderUltimatum(Bytes) ->

%% attribute reason(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rn-domain-disconnected';
1 -> 'rn-provider-initiated';
2 -> 'rn-token-purged';
3 -> 'rn-user-requested';
4 -> 'rn-channel-purged';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end,
Res1 = {'DisconnectProviderUltimatum',Term1},
{Res1,Bytes1}.

enc_RejectMCSPDUUltimatum(Val) ->
[begin
%% attribute diagnostic(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'dc-inconsistent-merge' ->
<<0:4>>;
Enc1@element =:= 'dc-forbidden-PDU-downward' ->
<<1:4>>;
Enc1@element =:= 'dc-forbidden-PDU-upward' ->
<<2:4>>;
Enc1@element =:= 'dc-invalid-BER-encoding' ->
<<3:4>>;
Enc1@element =:= 'dc-invalid-PER-encoding' ->
<<4:4>>;
Enc1@element =:= 'dc-misrouted-user' ->
<<5:4>>;
Enc1@element =:= 'dc-unrequested-confirm' ->
<<6:4>>;
Enc1@element =:= 'dc-wrong-transport-priority' ->
<<7:4>>;
Enc1@element =:= 'dc-channel-id-conflict' ->
<<8:4>>;
Enc1@element =:= 'dc-token-id-conflict' ->
<<9:4>>;
Enc1@element =:= 'dc-not-user-id-channel' ->
<<10:4>>;
Enc1@element =:= 'dc-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'dc-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'dc-too-many-users' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align|begin
%% attribute initialOctets(2) with type OCTET STRING
Enc3@element = element(3, Val),
Enc4@len = byte_size(Enc3@element),
if Enc4@len < 128 ->
[Enc4@len|Enc3@element];
Enc4@len < 16384 ->
[<<2:2,Enc4@len:14>>|Enc3@element];
true ->
encode_fragmented(Enc3@element, 8)
end
end].


dec_RejectMCSPDUUltimatum(Bytes) ->

%% attribute diagnostic(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'dc-inconsistent-merge';
1 -> 'dc-forbidden-PDU-downward';
2 -> 'dc-forbidden-PDU-upward';
3 -> 'dc-invalid-BER-encoding';
4 -> 'dc-invalid-PER-encoding';
5 -> 'dc-misrouted-user';
6 -> 'dc-unrequested-confirm';
7 -> 'dc-wrong-transport-priority';
8 -> 'dc-channel-id-conflict';
9 -> 'dc-token-id-conflict';
10 -> 'dc-not-user-id-channel';
11 -> 'dc-too-many-channels';
12 -> 'dc-too-many-tokens';
13 -> 'dc-too-many-users';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end,

%% attribute initialOctets(2) with type OCTET STRING
{Term2,Bytes2} = begin
V2@Pad3 = bit_size(Bytes1) band 7,
{V2@V0,V2@Buf1} = case Bytes1 of
<<_:V2@Pad3,0:1,V2@V5:7,V2@V7:V2@V5/binary-unit:8,V2@Buf8/bitstring>> ->
{V2@V7,V2@Buf8};
<<_:V2@Pad3,1:1,0:1,V2@V6:14,V2@V8:V2@V6/binary-unit:8,V2@Buf9/bitstring>> ->
{V2@V8,V2@Buf9};
<<_:V2@Pad3,1:1,1:1,V2@V6:6,V2@Buf7/bitstring>> ->
{V2@V8,V2@Buf9}  = decode_fragmented(V2@V6, V2@Buf7, 8),
{V2@V8,V2@Buf9}
end,
V2@Conv10 = binary:copy(V2@V0),
{V2@Conv10,V2@Buf1}
end,
Res1 = {'RejectMCSPDUUltimatum',Term1,Term2},
{Res1,Bytes2}.

enc_AttachUserRequest(Val) ->
[].


dec_AttachUserRequest(Bytes) ->
Res1 = {'AttachUserRequest'},
{Res1,Bytes}.

enc_AttachUserConfirm(Val) ->
[begin
Enc1@element = element(3, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute result(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= 'rt-successful' ->
<<0:4>>;
Enc2@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc2@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc2@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc2@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc2@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc2@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc2@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc2@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc2@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc2@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc2@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc2@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc2@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc2@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc2@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end
end|begin
%% attribute initiator(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element =:= asn1_NOVALUE ->
[];
Enc4@element bsr 16 =:= 0 ->
[align|<<Enc4@element:16>>];
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end].


dec_AttachUserConfirm(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute result(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:4/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V2@Int2,V2@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes3} = case Opt band 1 of
1 ->
begin
V3@Pad2 = bit_size(Bytes2) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes2}
end,
Res1 = {'AttachUserConfirm',Term1,Term2},
{Res1,Bytes3}.

enc_DetachUserRequest(Val) ->
[begin
%% attribute reason(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rn-domain-disconnected' ->
<<0:3>>;
Enc1@element =:= 'rn-provider-initiated' ->
<<1:3>>;
Enc1@element =:= 'rn-token-purged' ->
<<2:3>>;
Enc1@element =:= 'rn-user-requested' ->
<<3:3>>;
Enc1@element =:= 'rn-channel-purged' ->
<<4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end|begin
%% attribute userIds(2) with type SET OF
Enc3@element = element(3, Val),
enc_DetachUserRequest_userIds(Enc3@element)
end].
enc_DetachUserRequest_userIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_DetachUserRequest(Bytes) ->

%% attribute reason(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rn-domain-disconnected';
1 -> 'rn-provider-initiated';
2 -> 'rn-token-purged';
3 -> 'rn-user-requested';
4 -> 'rn-channel-purged';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end,

%% attribute userIds(2) with type SET OF
{Term2,Bytes2} = dec_DetachUserRequest_userIds(Bytes1),
Res1 = {'DetachUserRequest',Term1,Term2},
{Res1,Bytes2}.


dec_DetachUserRequest_userIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components15(V1@V0, V1@Buf1, []).

enc_DetachUserIndication(Val) ->
[begin
%% attribute reason(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rn-domain-disconnected' ->
<<0:3>>;
Enc1@element =:= 'rn-provider-initiated' ->
<<1:3>>;
Enc1@element =:= 'rn-token-purged' ->
<<2:3>>;
Enc1@element =:= 'rn-user-requested' ->
<<3:3>>;
Enc1@element =:= 'rn-channel-purged' ->
<<4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end|begin
%% attribute userIds(2) with type SET OF
Enc3@element = element(3, Val),
enc_DetachUserIndication_userIds(Enc3@element)
end].
enc_DetachUserIndication_userIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_DetachUserIndication(Bytes) ->

%% attribute reason(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rn-domain-disconnected';
1 -> 'rn-provider-initiated';
2 -> 'rn-token-purged';
3 -> 'rn-user-requested';
4 -> 'rn-channel-purged';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end,

%% attribute userIds(2) with type SET OF
{Term2,Bytes2} = dec_DetachUserIndication_userIds(Bytes1),
Res1 = {'DetachUserIndication',Term1,Term2},
{Res1,Bytes2}.


dec_DetachUserIndication_userIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components16(V1@V0, V1@Buf1, []).

enc_ChannelJoinRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_ChannelJoinRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'ChannelJoinRequest',Term1,Term2},
{Res1,Bytes2}.

enc_ChannelJoinConfirm(Val) ->
[begin
Enc1@element = element(5, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute result(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= 'rt-successful' ->
<<0:4>>;
Enc2@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc2@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc2@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc2@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc2@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc2@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc2@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc2@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc2@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc2@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc2@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc2@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc2@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc2@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc2@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end
end,
align,
begin
%% attribute initiator(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element bsr 16 =:= 0 ->
<<Enc4@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end,
begin
%% attribute requested(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element bsr 16 =:= 0 ->
<<Enc6@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end|begin
%% attribute channelId(4) with type INTEGER
Enc8@element = element(5, Val),
if Enc8@element =:= asn1_NOVALUE ->
[];
Enc8@element bsr 16 =:= 0 ->
<<Enc8@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc8@element}}})
end
end].


dec_ChannelJoinConfirm(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute result(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:4/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V2@Int2,V2@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes3} = begin
V3@Pad2 = bit_size(Bytes2) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute requested(3) with type INTEGER
{Term3,Bytes4} = begin
<<V4@V0:2/unsigned-unit:8,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end,

%% attribute channelId(4) with type INTEGER
{Term4,Bytes5} = case Opt band 1 of
1 ->
begin
V5@Pad2 = bit_size(Bytes4) band 7,
<<_:V5@Pad2,V5@V0:2/unsigned-unit:8,V5@Buf1/bitstring>> = Bytes4,
{V5@V0,V5@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes4}
end,
Res1 = {'ChannelJoinConfirm',Term1,Term2,Term3,Term4},
{Res1,Bytes5}.

enc_ChannelLeaveRequest(Val) ->
%% attribute channelIds(1) with type SET OF
Enc1@element = element(2, Val),
enc_ChannelLeaveRequest_channelIds(Enc1@element).
enc_ChannelLeaveRequest_channelIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_ChannelLeaveRequest(Bytes) ->

%% attribute channelIds(1) with type SET OF
{Term1,Bytes1} = dec_ChannelLeaveRequest_channelIds(Bytes),
Res1 = {'ChannelLeaveRequest',Term1},
{Res1,Bytes1}.


dec_ChannelLeaveRequest_channelIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components17(V1@V0, V1@Buf1, []).

enc_ChannelConveneRequest(Val) ->
[align|begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end].


dec_ChannelConveneRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
Res1 = {'ChannelConveneRequest',Term1},
{Res1,Bytes1}.

enc_ChannelConveneConfirm(Val) ->
[begin
Enc1@element = element(4, Val),
if Enc1@element =:= asn1_NOVALUE ->
<<0:1>>;
true ->
<<1:1>>
end
end,
begin
%% attribute result(1) with type ENUMERATED
Enc2@element = element(2, Val),
if Enc2@element =:= 'rt-successful' ->
<<0:4>>;
Enc2@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc2@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc2@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc2@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc2@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc2@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc2@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc2@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc2@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc2@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc2@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc2@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc2@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc2@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc2@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc2@element}}})
end
end,
align,
begin
%% attribute initiator(2) with type INTEGER
Enc4@element = element(3, Val),
if Enc4@element bsr 16 =:= 0 ->
<<Enc4@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc4@element}}})
end
end|begin
%% attribute channelId(3) with type INTEGER
Enc6@element = element(4, Val),
if Enc6@element =:= asn1_NOVALUE ->
[];
Enc6@element bsr 16 =:= 0 ->
<<Enc6@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc6@element}}})
end
end].


dec_ChannelConveneConfirm(Bytes) ->
{Opt,Bytes1} = begin
<<V1@V0:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute result(1) with type ENUMERATED
{Term1,Bytes2} = begin
<<V2@V0:4/unsigned-unit:1,V2@Buf1/bitstring>> = Bytes1,
V2@Int2 = case V2@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V2@Int2,V2@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes3} = begin
V3@Pad2 = bit_size(Bytes2) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,

%% attribute channelId(3) with type INTEGER
{Term3,Bytes4} = case Opt band 1 of
1 ->
begin
V4@Pad2 = bit_size(Bytes3) band 7,
<<_:V4@Pad2,V4@V0:2/unsigned-unit:8,V4@Buf1/bitstring>> = Bytes3,
{V4@V0,V4@Buf1}
end;
0 ->
{asn1_NOVALUE,Bytes3}
end,
Res1 = {'ChannelConveneConfirm',Term1,Term2,Term3},
{Res1,Bytes4}.

enc_ChannelDisbandRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_ChannelDisbandRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,
Res1 = {'ChannelDisbandRequest',Term1,Term2},
{Res1,Bytes2}.

enc_ChannelDisbandIndication(Val) ->
[align|begin
%% attribute channelId(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end].


dec_ChannelDisbandIndication(Bytes) ->

%% attribute channelId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
Res1 = {'ChannelDisbandIndication',Term1},
{Res1,Bytes1}.

enc_ChannelAdmitRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute userIds(3) with type SET OF
Enc5@element = element(4, Val),
enc_ChannelAdmitRequest_userIds(Enc5@element)
end].
enc_ChannelAdmitRequest_userIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_ChannelAdmitRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute userIds(3) with type SET OF
{Term3,Bytes3} = dec_ChannelAdmitRequest_userIds(Bytes2),
Res1 = {'ChannelAdmitRequest',Term1,Term2,Term3},
{Res1,Bytes3}.


dec_ChannelAdmitRequest_userIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components18(V1@V0, V1@Buf1, []).

enc_ChannelAdmitIndication(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute userIds(3) with type SET OF
Enc5@element = element(4, Val),
enc_ChannelAdmitIndication_userIds(Enc5@element)
end].
enc_ChannelAdmitIndication_userIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_ChannelAdmitIndication(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute userIds(3) with type SET OF
{Term3,Bytes3} = dec_ChannelAdmitIndication_userIds(Bytes2),
Res1 = {'ChannelAdmitIndication',Term1,Term2,Term3},
{Res1,Bytes3}.


dec_ChannelAdmitIndication_userIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components19(V1@V0, V1@Buf1, []).

enc_ChannelExpelRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute userIds(3) with type SET OF
Enc5@element = element(4, Val),
enc_ChannelExpelRequest_userIds(Enc5@element)
end].
enc_ChannelExpelRequest_userIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_ChannelExpelRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute userIds(3) with type SET OF
{Term3,Bytes3} = dec_ChannelExpelRequest_userIds(Bytes2),
Res1 = {'ChannelExpelRequest',Term1,Term2,Term3},
{Res1,Bytes3}.


dec_ChannelExpelRequest_userIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components20(V1@V0, V1@Buf1, []).

enc_ChannelExpelIndication(Val) ->
[align,
begin
%% attribute channelId(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute userIds(2) with type SET OF
Enc3@element = element(3, Val),
enc_ChannelExpelIndication_userIds(Enc3@element)
end].
enc_ChannelExpelIndication_userIds(Val) ->
Enc2@len = length(Val),
[if Enc2@len < 128 ->
[align,
Enc2@len];
Enc2@len < 16384 ->
[align|<<2:2,Enc2@len:14>>]
end|[if Comp bsr 16 =:= 0 ->
<<Comp:16>>;
true ->
exit({error,{asn1,{illegal_integer,Comp}}})
end || Comp <- Val]].



dec_ChannelExpelIndication(Bytes) ->

%% attribute channelId(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute userIds(2) with type SET OF
{Term2,Bytes2} = dec_ChannelExpelIndication_userIds(Bytes1),
Res1 = {'ChannelExpelIndication',Term1,Term2},
{Res1,Bytes2}.


dec_ChannelExpelIndication_userIds(Bytes) ->
%% Length with constraint no
V1@Pad3 = bit_size(Bytes) band 7,
{V1@V0,V1@Buf1} = case Bytes of
<<_:V1@Pad3,0:1,V1@V5:7,V1@Buf6/bitstring>> ->
{V1@V5,V1@Buf6};
<<_:V1@Pad3,1:1,0:1,V1@V6:14,V1@Buf7/bitstring>> ->
{V1@V6,V1@Buf7}
end,
dec_components21(V1@V0, V1@Buf1, []).

enc_SendDataRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute dataPriority(3) with type ENUMERATED
Enc5@element = element(4, Val),
if Enc5@element =:= top ->
<<0:2>>;
Enc5@element =:= high ->
<<1:2>>;
Enc5@element =:= medium ->
<<2:2>>;
Enc5@element =:= low ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end,
begin
%% attribute segmentation(4) with type BIT STRING
Enc7@element = element(5, Val),
Enc8@bs = try bit_string_name2pos_1(Enc7@element) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Enc7@element, 2)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 2 ->
[Enc8@bs,
align]
end
end|begin
%% attribute userData(5) with type OCTET STRING
Enc9@element = element(6, Val),
Enc10@len = byte_size(Enc9@element),
if Enc10@len < 128 ->
[Enc10@len|Enc9@element];
Enc10@len < 16384 ->
[<<2:2,Enc10@len:14>>|Enc9@element];
true ->
encode_fragmented(Enc9@element, 8)
end
end].


dec_SendDataRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dataPriority(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> top;
1 -> high;
2 -> medium;
3 -> low
end,
{V3@Int2,V3@Buf1}
end,

%% attribute segmentation(4) with type BIT STRING
{Term4,Bytes4} = begin
<<V4@V0:2/binary-unit:1,V4@Buf1/bitstring>> = Bytes3,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{'begin',0},{'end',1}]),V4@Buf1},
{V4@V2,V4@Buf3}
end,

%% attribute userData(5) with type OCTET STRING
{Term5,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<_:4,0:1,V5@V4:7,V5@V6:V5@V4/binary-unit:8,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<_:4,1:1,0:1,V5@V5:14,V5@V7:V5@V5/binary-unit:8,V5@Buf8/bitstring>> ->
{V5@V7,V5@Buf8};
<<_:4,1:1,1:1,V5@V5:6,V5@Buf6/bitstring>> ->
{V5@V7,V5@Buf8}  = decode_fragmented(V5@V5, V5@Buf6, 8),
{V5@V7,V5@Buf8}
end,
V5@Conv9 = binary:copy(V5@V0),
{V5@Conv9,V5@Buf1}
end,
Res1 = {'SendDataRequest',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes5}.

enc_SendDataIndication(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute dataPriority(3) with type ENUMERATED
Enc5@element = element(4, Val),
if Enc5@element =:= top ->
<<0:2>>;
Enc5@element =:= high ->
<<1:2>>;
Enc5@element =:= medium ->
<<2:2>>;
Enc5@element =:= low ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end,
begin
%% attribute segmentation(4) with type BIT STRING
Enc7@element = element(5, Val),
Enc8@bs = try bit_string_name2pos_1(Enc7@element) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Enc7@element, 2)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 2 ->
[Enc8@bs,
align]
end
end|begin
%% attribute userData(5) with type OCTET STRING
Enc9@element = element(6, Val),
Enc10@len = byte_size(Enc9@element),
if Enc10@len < 128 ->
[Enc10@len|Enc9@element];
Enc10@len < 16384 ->
[<<2:2,Enc10@len:14>>|Enc9@element];
true ->
encode_fragmented(Enc9@element, 8)
end
end].


dec_SendDataIndication(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dataPriority(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> top;
1 -> high;
2 -> medium;
3 -> low
end,
{V3@Int2,V3@Buf1}
end,

%% attribute segmentation(4) with type BIT STRING
{Term4,Bytes4} = begin
<<V4@V0:2/binary-unit:1,V4@Buf1/bitstring>> = Bytes3,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{'begin',0},{'end',1}]),V4@Buf1},
{V4@V2,V4@Buf3}
end,

%% attribute userData(5) with type OCTET STRING
{Term5,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<_:4,0:1,V5@V4:7,V5@V6:V5@V4/binary-unit:8,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<_:4,1:1,0:1,V5@V5:14,V5@V7:V5@V5/binary-unit:8,V5@Buf8/bitstring>> ->
{V5@V7,V5@Buf8};
<<_:4,1:1,1:1,V5@V5:6,V5@Buf6/bitstring>> ->
{V5@V7,V5@Buf8}  = decode_fragmented(V5@V5, V5@Buf6, 8),
{V5@V7,V5@Buf8}
end,
V5@Conv9 = binary:copy(V5@V0),
{V5@Conv9,V5@Buf1}
end,
Res1 = {'SendDataIndication',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes5}.

enc_UniformSendDataRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute dataPriority(3) with type ENUMERATED
Enc5@element = element(4, Val),
if Enc5@element =:= top ->
<<0:2>>;
Enc5@element =:= high ->
<<1:2>>;
Enc5@element =:= medium ->
<<2:2>>;
Enc5@element =:= low ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end,
begin
%% attribute segmentation(4) with type BIT STRING
Enc7@element = element(5, Val),
Enc8@bs = try bit_string_name2pos_1(Enc7@element) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Enc7@element, 2)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 2 ->
[Enc8@bs,
align]
end
end|begin
%% attribute userData(5) with type OCTET STRING
Enc9@element = element(6, Val),
Enc10@len = byte_size(Enc9@element),
if Enc10@len < 128 ->
[Enc10@len|Enc9@element];
Enc10@len < 16384 ->
[<<2:2,Enc10@len:14>>|Enc9@element];
true ->
encode_fragmented(Enc9@element, 8)
end
end].


dec_UniformSendDataRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dataPriority(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> top;
1 -> high;
2 -> medium;
3 -> low
end,
{V3@Int2,V3@Buf1}
end,

%% attribute segmentation(4) with type BIT STRING
{Term4,Bytes4} = begin
<<V4@V0:2/binary-unit:1,V4@Buf1/bitstring>> = Bytes3,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{'begin',0},{'end',1}]),V4@Buf1},
{V4@V2,V4@Buf3}
end,

%% attribute userData(5) with type OCTET STRING
{Term5,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<_:4,0:1,V5@V4:7,V5@V6:V5@V4/binary-unit:8,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<_:4,1:1,0:1,V5@V5:14,V5@V7:V5@V5/binary-unit:8,V5@Buf8/bitstring>> ->
{V5@V7,V5@Buf8};
<<_:4,1:1,1:1,V5@V5:6,V5@Buf6/bitstring>> ->
{V5@V7,V5@Buf8}  = decode_fragmented(V5@V5, V5@Buf6, 8),
{V5@V7,V5@Buf8}
end,
V5@Conv9 = binary:copy(V5@V0),
{V5@Conv9,V5@Buf1}
end,
Res1 = {'UniformSendDataRequest',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes5}.

enc_UniformSendDataIndication(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute channelId(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute dataPriority(3) with type ENUMERATED
Enc5@element = element(4, Val),
if Enc5@element =:= top ->
<<0:2>>;
Enc5@element =:= high ->
<<1:2>>;
Enc5@element =:= medium ->
<<2:2>>;
Enc5@element =:= low ->
<<3:2>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end,
begin
%% attribute segmentation(4) with type BIT STRING
Enc7@element = element(5, Val),
Enc8@bs = try bit_string_name2pos_1(Enc7@element) of
Enc8@positions ->
bitstring_from_positions(Enc8@positions, 2)
catch throw:invalid ->
adjust_trailing_zeroes(Enc7@element, 2)
end,
Enc8@bits = bit_size(Enc8@bs),
if Enc8@bits =:= 2 ->
[Enc8@bs,
align]
end
end|begin
%% attribute userData(5) with type OCTET STRING
Enc9@element = element(6, Val),
Enc10@len = byte_size(Enc9@element),
if Enc10@len < 128 ->
[Enc10@len|Enc9@element];
Enc10@len < 16384 ->
[<<2:2,Enc10@len:14>>|Enc9@element];
true ->
encode_fragmented(Enc9@element, 8)
end
end].


dec_UniformSendDataIndication(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute channelId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute dataPriority(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> top;
1 -> high;
2 -> medium;
3 -> low
end,
{V3@Int2,V3@Buf1}
end,

%% attribute segmentation(4) with type BIT STRING
{Term4,Bytes4} = begin
<<V4@V0:2/binary-unit:1,V4@Buf1/bitstring>> = Bytes3,
{V4@V2,V4@Buf3}  = {decode_named_bit_string(V4@V0, [{'begin',0},{'end',1}]),V4@Buf1},
{V4@V2,V4@Buf3}
end,

%% attribute userData(5) with type OCTET STRING
{Term5,Bytes5} = begin
{V5@V0,V5@Buf1} = case Bytes4 of
<<_:4,0:1,V5@V4:7,V5@V6:V5@V4/binary-unit:8,V5@Buf7/bitstring>> ->
{V5@V6,V5@Buf7};
<<_:4,1:1,0:1,V5@V5:14,V5@V7:V5@V5/binary-unit:8,V5@Buf8/bitstring>> ->
{V5@V7,V5@Buf8};
<<_:4,1:1,1:1,V5@V5:6,V5@Buf6/bitstring>> ->
{V5@V7,V5@Buf8}  = decode_fragmented(V5@V5, V5@Buf6, 8),
{V5@V7,V5@Buf8}
end,
V5@Conv9 = binary:copy(V5@V0),
{V5@Conv9,V5@Buf1}
end,
Res1 = {'UniformSendDataIndication',Term1,Term2,Term3,Term4,Term5},
{Res1,Bytes5}.

enc_TokenGrabRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenGrabRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,
Res1 = {'TokenGrabRequest',Term1,Term2},
{Res1,Bytes2}.

enc_TokenGrabConfirm(Val) ->
[begin
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align,
begin
%% attribute initiator(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute tokenId(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 65535 ->
<<Enc5@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute tokenStatus(4) with type ENUMERATED
Enc7@element = element(5, Val),
if Enc7@element =:= notInUse ->
<<0:3>>;
Enc7@element =:= selfGrabbed ->
<<1:3>>;
Enc7@element =:= otherGrabbed ->
<<2:3>>;
Enc7@element =:= selfInhibited ->
<<3:3>>;
Enc7@element =:= otherInhibited ->
<<4:3>>;
Enc7@element =:= selfRecipient ->
<<5:3>>;
Enc7@element =:= selfGiving ->
<<6:3>>;
Enc7@element =:= otherGiving ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end].


dec_TokenGrabConfirm(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tokenId(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute tokenStatus(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V4@V0:3/unsigned-unit:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> notInUse;
1 -> selfGrabbed;
2 -> otherGrabbed;
3 -> selfInhibited;
4 -> otherInhibited;
5 -> selfRecipient;
6 -> selfGiving;
7 -> otherGiving
end,
{V4@Int2,V4@Buf1}
end,
Res1 = {'TokenGrabConfirm',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

enc_TokenInhibitRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenInhibitRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,
Res1 = {'TokenInhibitRequest',Term1,Term2},
{Res1,Bytes2}.

enc_TokenInhibitConfirm(Val) ->
[begin
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align,
begin
%% attribute initiator(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute tokenId(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 65535 ->
<<Enc5@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute tokenStatus(4) with type ENUMERATED
Enc7@element = element(5, Val),
if Enc7@element =:= notInUse ->
<<0:3>>;
Enc7@element =:= selfGrabbed ->
<<1:3>>;
Enc7@element =:= otherGrabbed ->
<<2:3>>;
Enc7@element =:= selfInhibited ->
<<3:3>>;
Enc7@element =:= otherInhibited ->
<<4:3>>;
Enc7@element =:= selfRecipient ->
<<5:3>>;
Enc7@element =:= selfGiving ->
<<6:3>>;
Enc7@element =:= otherGiving ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end].


dec_TokenInhibitConfirm(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tokenId(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute tokenStatus(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V4@V0:3/unsigned-unit:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> notInUse;
1 -> selfGrabbed;
2 -> otherGrabbed;
3 -> selfInhibited;
4 -> otherInhibited;
5 -> selfRecipient;
6 -> selfGiving;
7 -> otherGiving
end,
{V4@Int2,V4@Buf1}
end,
Res1 = {'TokenInhibitConfirm',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

enc_TokenGiveRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute recipient(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_TokenGiveRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute recipient(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'TokenGiveRequest',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_TokenGiveIndication(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute recipient(3) with type INTEGER
Enc5@element = element(4, Val),
if Enc5@element bsr 16 =:= 0 ->
<<Enc5@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_TokenGiveIndication(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute recipient(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
{V3@V0,V3@Buf1}
end,
Res1 = {'TokenGiveIndication',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_TokenGiveResponse(Val) ->
[begin
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align,
begin
%% attribute recipient(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute tokenId(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 65535 ->
<<Enc5@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end].


dec_TokenGiveResponse(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute recipient(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tokenId(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,
Res1 = {'TokenGiveResponse',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_TokenGiveConfirm(Val) ->
[begin
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align,
begin
%% attribute initiator(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute tokenId(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 65535 ->
<<Enc5@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute tokenStatus(4) with type ENUMERATED
Enc7@element = element(5, Val),
if Enc7@element =:= notInUse ->
<<0:3>>;
Enc7@element =:= selfGrabbed ->
<<1:3>>;
Enc7@element =:= otherGrabbed ->
<<2:3>>;
Enc7@element =:= selfInhibited ->
<<3:3>>;
Enc7@element =:= otherInhibited ->
<<4:3>>;
Enc7@element =:= selfRecipient ->
<<5:3>>;
Enc7@element =:= selfGiving ->
<<6:3>>;
Enc7@element =:= otherGiving ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end].


dec_TokenGiveConfirm(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tokenId(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute tokenStatus(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V4@V0:3/unsigned-unit:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> notInUse;
1 -> selfGrabbed;
2 -> otherGrabbed;
3 -> selfInhibited;
4 -> otherInhibited;
5 -> selfRecipient;
6 -> selfGiving;
7 -> otherGiving
end,
{V4@Int2,V4@Buf1}
end,
Res1 = {'TokenGiveConfirm',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

enc_TokenPleaseRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenPleaseRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,
Res1 = {'TokenPleaseRequest',Term1,Term2},
{Res1,Bytes2}.

enc_TokenPleaseIndication(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenPleaseIndication(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,
Res1 = {'TokenPleaseIndication',Term1,Term2},
{Res1,Bytes2}.

enc_TokenReleaseRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenReleaseRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,
Res1 = {'TokenReleaseRequest',Term1,Term2},
{Res1,Bytes2}.

enc_TokenReleaseConfirm(Val) ->
[begin
%% attribute result(1) with type ENUMERATED
Enc1@element = element(2, Val),
if Enc1@element =:= 'rt-successful' ->
<<0:4>>;
Enc1@element =:= 'rt-domain-merging' ->
<<1:4>>;
Enc1@element =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Enc1@element =:= 'rt-no-such-channel' ->
<<3:4>>;
Enc1@element =:= 'rt-no-such-domain' ->
<<4:4>>;
Enc1@element =:= 'rt-no-such-user' ->
<<5:4>>;
Enc1@element =:= 'rt-not-admitted' ->
<<6:4>>;
Enc1@element =:= 'rt-other-user-id' ->
<<7:4>>;
Enc1@element =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Enc1@element =:= 'rt-token-not-available' ->
<<9:4>>;
Enc1@element =:= 'rt-token-not-possessed' ->
<<10:4>>;
Enc1@element =:= 'rt-too-many-channels' ->
<<11:4>>;
Enc1@element =:= 'rt-too-many-tokens' ->
<<12:4>>;
Enc1@element =:= 'rt-too-many-users' ->
<<13:4>>;
Enc1@element =:= 'rt-unspecified-failure' ->
<<14:4>>;
Enc1@element =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc1@element}}})
end
end,
align,
begin
%% attribute initiator(2) with type INTEGER
Enc3@element = element(3, Val),
if Enc3@element bsr 16 =:= 0 ->
<<Enc3@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end,
begin
%% attribute tokenId(3) with type INTEGER
Enc5@element = element(4, Val),
Enc5@element@sub = Enc5@element - 1,
if 0 =< Enc5@element@sub, Enc5@element@sub < 65535 ->
<<Enc5@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc5@element}}})
end
end|begin
%% attribute tokenStatus(4) with type ENUMERATED
Enc7@element = element(5, Val),
if Enc7@element =:= notInUse ->
<<0:3>>;
Enc7@element =:= selfGrabbed ->
<<1:3>>;
Enc7@element =:= otherGrabbed ->
<<2:3>>;
Enc7@element =:= selfInhibited ->
<<3:3>>;
Enc7@element =:= otherInhibited ->
<<4:3>>;
Enc7@element =:= selfRecipient ->
<<5:3>>;
Enc7@element =:= selfGiving ->
<<6:3>>;
Enc7@element =:= otherGiving ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc7@element}}})
end
end].


dec_TokenReleaseConfirm(Bytes) ->

%% attribute result(1) with type ENUMERATED
{Term1,Bytes1} = begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end,

%% attribute initiator(2) with type INTEGER
{Term2,Bytes2} = begin
V2@Pad2 = bit_size(Bytes1) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
{V2@V0,V2@Buf1}
end,

%% attribute tokenId(3) with type INTEGER
{Term3,Bytes3} = begin
<<V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes2,
V3@Add2 = V3@V0 + 1,
{V3@Add2,V3@Buf1}
end,

%% attribute tokenStatus(4) with type ENUMERATED
{Term4,Bytes4} = begin
<<V4@V0:3/unsigned-unit:1,V4@Buf1/bitstring>> = Bytes3,
V4@Int2 = case V4@V0 of
0 -> notInUse;
1 -> selfGrabbed;
2 -> otherGrabbed;
3 -> selfInhibited;
4 -> otherInhibited;
5 -> selfRecipient;
6 -> selfGiving;
7 -> otherGiving
end,
{V4@Int2,V4@Buf1}
end,
Res1 = {'TokenReleaseConfirm',Term1,Term2,Term3,Term4},
{Res1,Bytes4}.

enc_TokenTestRequest(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end|begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end].


dec_TokenTestRequest(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,
Res1 = {'TokenTestRequest',Term1,Term2},
{Res1,Bytes2}.

enc_TokenTestConfirm(Val) ->
[align,
begin
%% attribute initiator(1) with type INTEGER
Enc1@element = element(2, Val),
if Enc1@element bsr 16 =:= 0 ->
<<Enc1@element:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc1@element}}})
end
end,
begin
%% attribute tokenId(2) with type INTEGER
Enc3@element = element(3, Val),
Enc3@element@sub = Enc3@element - 1,
if 0 =< Enc3@element@sub, Enc3@element@sub < 65535 ->
<<Enc3@element@sub:16>>;
true ->
exit({error,{asn1,{illegal_integer,Enc3@element}}})
end
end|begin
%% attribute tokenStatus(3) with type ENUMERATED
Enc5@element = element(4, Val),
if Enc5@element =:= notInUse ->
<<0:3>>;
Enc5@element =:= selfGrabbed ->
<<1:3>>;
Enc5@element =:= otherGrabbed ->
<<2:3>>;
Enc5@element =:= selfInhibited ->
<<3:3>>;
Enc5@element =:= otherInhibited ->
<<4:3>>;
Enc5@element =:= selfRecipient ->
<<5:3>>;
Enc5@element =:= selfGiving ->
<<6:3>>;
Enc5@element =:= otherGiving ->
<<7:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Enc5@element}}})
end
end].


dec_TokenTestConfirm(Bytes) ->

%% attribute initiator(1) with type INTEGER
{Term1,Bytes1} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,

%% attribute tokenId(2) with type INTEGER
{Term2,Bytes2} = begin
<<V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes1,
V2@Add2 = V2@V0 + 1,
{V2@Add2,V2@Buf1}
end,

%% attribute tokenStatus(3) with type ENUMERATED
{Term3,Bytes3} = begin
<<V3@V0:3/unsigned-unit:1,V3@Buf1/bitstring>> = Bytes2,
V3@Int2 = case V3@V0 of
0 -> notInUse;
1 -> selfGrabbed;
2 -> otherGrabbed;
3 -> selfInhibited;
4 -> otherInhibited;
5 -> selfRecipient;
6 -> selfGiving;
7 -> otherGiving
end,
{V3@Int2,V3@Buf1}
end,
Res1 = {'TokenTestConfirm',Term1,Term2,Term3},
{Res1,Bytes3}.

enc_Reason(Val) ->
if Val =:= 'rn-domain-disconnected' ->
<<0:3>>;
Val =:= 'rn-provider-initiated' ->
<<1:3>>;
Val =:= 'rn-token-purged' ->
<<2:3>>;
Val =:= 'rn-user-requested' ->
<<3:3>>;
Val =:= 'rn-channel-purged' ->
<<4:3>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Reason(Bytes) ->
begin
<<V1@V0:3/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rn-domain-disconnected';
1 -> 'rn-provider-initiated';
2 -> 'rn-token-purged';
3 -> 'rn-user-requested';
4 -> 'rn-channel-purged';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_Result(Val) ->
if Val =:= 'rt-successful' ->
<<0:4>>;
Val =:= 'rt-domain-merging' ->
<<1:4>>;
Val =:= 'rt-domain-not-hierarchical' ->
<<2:4>>;
Val =:= 'rt-no-such-channel' ->
<<3:4>>;
Val =:= 'rt-no-such-domain' ->
<<4:4>>;
Val =:= 'rt-no-such-user' ->
<<5:4>>;
Val =:= 'rt-not-admitted' ->
<<6:4>>;
Val =:= 'rt-other-user-id' ->
<<7:4>>;
Val =:= 'rt-parameters-unacceptable' ->
<<8:4>>;
Val =:= 'rt-token-not-available' ->
<<9:4>>;
Val =:= 'rt-token-not-possessed' ->
<<10:4>>;
Val =:= 'rt-too-many-channels' ->
<<11:4>>;
Val =:= 'rt-too-many-tokens' ->
<<12:4>>;
Val =:= 'rt-too-many-users' ->
<<13:4>>;
Val =:= 'rt-unspecified-failure' ->
<<14:4>>;
Val =:= 'rt-user-rejected' ->
<<15:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Result(Bytes) ->
begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'rt-successful';
1 -> 'rt-domain-merging';
2 -> 'rt-domain-not-hierarchical';
3 -> 'rt-no-such-channel';
4 -> 'rt-no-such-domain';
5 -> 'rt-no-such-user';
6 -> 'rt-not-admitted';
7 -> 'rt-other-user-id';
8 -> 'rt-parameters-unacceptable';
9 -> 'rt-token-not-available';
10 -> 'rt-token-not-possessed';
11 -> 'rt-too-many-channels';
12 -> 'rt-too-many-tokens';
13 -> 'rt-too-many-users';
14 -> 'rt-unspecified-failure';
15 -> 'rt-user-rejected'
end,
{V1@Int2,V1@Buf1}
end.

enc_Diagnostic(Val) ->
if Val =:= 'dc-inconsistent-merge' ->
<<0:4>>;
Val =:= 'dc-forbidden-PDU-downward' ->
<<1:4>>;
Val =:= 'dc-forbidden-PDU-upward' ->
<<2:4>>;
Val =:= 'dc-invalid-BER-encoding' ->
<<3:4>>;
Val =:= 'dc-invalid-PER-encoding' ->
<<4:4>>;
Val =:= 'dc-misrouted-user' ->
<<5:4>>;
Val =:= 'dc-unrequested-confirm' ->
<<6:4>>;
Val =:= 'dc-wrong-transport-priority' ->
<<7:4>>;
Val =:= 'dc-channel-id-conflict' ->
<<8:4>>;
Val =:= 'dc-token-id-conflict' ->
<<9:4>>;
Val =:= 'dc-not-user-id-channel' ->
<<10:4>>;
Val =:= 'dc-too-many-channels' ->
<<11:4>>;
Val =:= 'dc-too-many-tokens' ->
<<12:4>>;
Val =:= 'dc-too-many-users' ->
<<13:4>>;
true ->
exit({error,{asn1,{illegal_enumerated,Val}}})
end.


dec_Diagnostic(Bytes) ->
begin
<<V1@V0:4/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
V1@Int2 = case V1@V0 of
0 -> 'dc-inconsistent-merge';
1 -> 'dc-forbidden-PDU-downward';
2 -> 'dc-forbidden-PDU-upward';
3 -> 'dc-invalid-BER-encoding';
4 -> 'dc-invalid-PER-encoding';
5 -> 'dc-misrouted-user';
6 -> 'dc-unrequested-confirm';
7 -> 'dc-wrong-transport-priority';
8 -> 'dc-channel-id-conflict';
9 -> 'dc-token-id-conflict';
10 -> 'dc-not-user-id-channel';
11 -> 'dc-too-many-channels';
12 -> 'dc-too-many-tokens';
13 -> 'dc-too-many-users';
_ -> exit({error,{asn1,{decode_enumerated,V1@V0}}})
end,
{V1@Int2,V1@Buf1}
end.

enc_ConnectMCSPDU(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= 'connect-initial' ->
[<<0:2>>|'enc_Connect-Initial'(ChoiceVal)];
ChoiceTag =:= 'connect-response' ->
[<<1:2>>|'enc_Connect-Response'(ChoiceVal)];
ChoiceTag =:= 'connect-additional' ->
[<<2:2>>|'enc_Connect-Additional'(ChoiceVal)];
ChoiceTag =:= 'connect-result' ->
[<<3:2>>|'enc_Connect-Result'(ChoiceVal)]
end.


dec_ConnectMCSPDU(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:2/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
'dec_Connect-Initial'(Bytes1)
end,
{{'connect-initial',Val},NewBytes};
1 ->
{Val,NewBytes} = begin
'dec_Connect-Response'(Bytes1)
end,
{{'connect-response',Val},NewBytes};
2 ->
{Val,NewBytes} = begin
'dec_Connect-Additional'(Bytes1)
end,
{{'connect-additional',Val},NewBytes};
3 ->
{Val,NewBytes} = begin
'dec_Connect-Result'(Bytes1)
end,
{{'connect-result',Val},NewBytes}
end.
enc_DomainMCSPDU(Val) ->
{ChoiceTag,ChoiceVal} = Val,
if ChoiceTag =:= plumbDomainIndication ->
[<<0:6>>|enc_PlumbDomainIndication(ChoiceVal)];
ChoiceTag =:= erectDomainRequest ->
[<<1:6>>|enc_ErectDomainRequest(ChoiceVal)];
ChoiceTag =:= mergeChannelsRequest ->
[<<2:6>>|enc_MergeChannelsRequest(ChoiceVal)];
ChoiceTag =:= mergeChannelsConfirm ->
[<<3:6>>|enc_MergeChannelsConfirm(ChoiceVal)];
ChoiceTag =:= purgeChannelsIndication ->
[<<4:6>>|enc_PurgeChannelsIndication(ChoiceVal)];
ChoiceTag =:= mergeTokensRequest ->
[<<5:6>>|enc_MergeTokensRequest(ChoiceVal)];
ChoiceTag =:= mergeTokensConfirm ->
[<<6:6>>|enc_MergeTokensConfirm(ChoiceVal)];
ChoiceTag =:= purgeTokensIndication ->
[<<7:6>>|enc_PurgeTokensIndication(ChoiceVal)];
ChoiceTag =:= disconnectProviderUltimatum ->
[<<8:6>>|enc_DisconnectProviderUltimatum(ChoiceVal)];
ChoiceTag =:= rejectMCSPDUUltimatum ->
[<<9:6>>|enc_RejectMCSPDUUltimatum(ChoiceVal)];
ChoiceTag =:= attachUserRequest ->
[<<10:6>>|enc_AttachUserRequest(ChoiceVal)];
ChoiceTag =:= attachUserConfirm ->
[<<11:6>>|enc_AttachUserConfirm(ChoiceVal)];
ChoiceTag =:= detachUserRequest ->
[<<12:6>>|enc_DetachUserRequest(ChoiceVal)];
ChoiceTag =:= detachUserIndication ->
[<<13:6>>|enc_DetachUserIndication(ChoiceVal)];
ChoiceTag =:= channelJoinRequest ->
[<<14:6>>|enc_ChannelJoinRequest(ChoiceVal)];
ChoiceTag =:= channelJoinConfirm ->
[<<15:6>>|enc_ChannelJoinConfirm(ChoiceVal)];
ChoiceTag =:= channelLeaveRequest ->
[<<16:6>>|enc_ChannelLeaveRequest(ChoiceVal)];
ChoiceTag =:= channelConveneRequest ->
[<<17:6>>|enc_ChannelConveneRequest(ChoiceVal)];
ChoiceTag =:= channelConveneConfirm ->
[<<18:6>>|enc_ChannelConveneConfirm(ChoiceVal)];
ChoiceTag =:= channelDisbandRequest ->
[<<19:6>>|enc_ChannelDisbandRequest(ChoiceVal)];
ChoiceTag =:= channelDisbandIndication ->
[<<20:6>>|enc_ChannelDisbandIndication(ChoiceVal)];
ChoiceTag =:= channelAdmitRequest ->
[<<21:6>>|enc_ChannelAdmitRequest(ChoiceVal)];
ChoiceTag =:= channelAdmitIndication ->
[<<22:6>>|enc_ChannelAdmitIndication(ChoiceVal)];
ChoiceTag =:= channelExpelRequest ->
[<<23:6>>|enc_ChannelExpelRequest(ChoiceVal)];
ChoiceTag =:= channelExpelIndication ->
[<<24:6>>|enc_ChannelExpelIndication(ChoiceVal)];
ChoiceTag =:= sendDataRequest ->
[<<25:6>>|enc_SendDataRequest(ChoiceVal)];
ChoiceTag =:= sendDataIndication ->
[<<26:6>>|enc_SendDataIndication(ChoiceVal)];
ChoiceTag =:= uniformSendDataRequest ->
[<<27:6>>|enc_UniformSendDataRequest(ChoiceVal)];
ChoiceTag =:= uniformSendDataIndication ->
[<<28:6>>|enc_UniformSendDataIndication(ChoiceVal)];
ChoiceTag =:= tokenGrabRequest ->
[<<29:6>>|enc_TokenGrabRequest(ChoiceVal)];
ChoiceTag =:= tokenGrabConfirm ->
[<<30:6>>|enc_TokenGrabConfirm(ChoiceVal)];
ChoiceTag =:= tokenInhibitRequest ->
[<<31:6>>|enc_TokenInhibitRequest(ChoiceVal)];
ChoiceTag =:= tokenInhibitConfirm ->
[<<32:6>>|enc_TokenInhibitConfirm(ChoiceVal)];
ChoiceTag =:= tokenGiveRequest ->
[<<33:6>>|enc_TokenGiveRequest(ChoiceVal)];
ChoiceTag =:= tokenGiveIndication ->
[<<34:6>>|enc_TokenGiveIndication(ChoiceVal)];
ChoiceTag =:= tokenGiveResponse ->
[<<35:6>>|enc_TokenGiveResponse(ChoiceVal)];
ChoiceTag =:= tokenGiveConfirm ->
[<<36:6>>|enc_TokenGiveConfirm(ChoiceVal)];
ChoiceTag =:= tokenPleaseRequest ->
[<<37:6>>|enc_TokenPleaseRequest(ChoiceVal)];
ChoiceTag =:= tokenPleaseIndication ->
[<<38:6>>|enc_TokenPleaseIndication(ChoiceVal)];
ChoiceTag =:= tokenReleaseRequest ->
[<<39:6>>|enc_TokenReleaseRequest(ChoiceVal)];
ChoiceTag =:= tokenReleaseConfirm ->
[<<40:6>>|enc_TokenReleaseConfirm(ChoiceVal)];
ChoiceTag =:= tokenTestRequest ->
[<<41:6>>|enc_TokenTestRequest(ChoiceVal)];
ChoiceTag =:= tokenTestConfirm ->
[<<42:6>>|enc_TokenTestConfirm(ChoiceVal)]
end.


dec_DomainMCSPDU(Bytes) ->
{Choice,Bytes1} = 
begin
<<V1@V0:6/unsigned-unit:1,V1@Buf1/bitstring>> = Bytes,
{V1@V0,V1@Buf1}
end,
case Choice of
0 ->
{Val,NewBytes} = begin
dec_PlumbDomainIndication(Bytes1)
end,
{{plumbDomainIndication,Val},NewBytes};
1 ->
{Val,NewBytes} = begin
dec_ErectDomainRequest(Bytes1)
end,
{{erectDomainRequest,Val},NewBytes};
2 ->
{Val,NewBytes} = begin
dec_MergeChannelsRequest(Bytes1)
end,
{{mergeChannelsRequest,Val},NewBytes};
3 ->
{Val,NewBytes} = begin
dec_MergeChannelsConfirm(Bytes1)
end,
{{mergeChannelsConfirm,Val},NewBytes};
4 ->
{Val,NewBytes} = begin
dec_PurgeChannelsIndication(Bytes1)
end,
{{purgeChannelsIndication,Val},NewBytes};
5 ->
{Val,NewBytes} = begin
dec_MergeTokensRequest(Bytes1)
end,
{{mergeTokensRequest,Val},NewBytes};
6 ->
{Val,NewBytes} = begin
dec_MergeTokensConfirm(Bytes1)
end,
{{mergeTokensConfirm,Val},NewBytes};
7 ->
{Val,NewBytes} = begin
dec_PurgeTokensIndication(Bytes1)
end,
{{purgeTokensIndication,Val},NewBytes};
8 ->
{Val,NewBytes} = begin
dec_DisconnectProviderUltimatum(Bytes1)
end,
{{disconnectProviderUltimatum,Val},NewBytes};
9 ->
{Val,NewBytes} = begin
dec_RejectMCSPDUUltimatum(Bytes1)
end,
{{rejectMCSPDUUltimatum,Val},NewBytes};
10 ->
{Val,NewBytes} = begin
dec_AttachUserRequest(Bytes1)
end,
{{attachUserRequest,Val},NewBytes};
11 ->
{Val,NewBytes} = begin
dec_AttachUserConfirm(Bytes1)
end,
{{attachUserConfirm,Val},NewBytes};
12 ->
{Val,NewBytes} = begin
dec_DetachUserRequest(Bytes1)
end,
{{detachUserRequest,Val},NewBytes};
13 ->
{Val,NewBytes} = begin
dec_DetachUserIndication(Bytes1)
end,
{{detachUserIndication,Val},NewBytes};
14 ->
{Val,NewBytes} = begin
dec_ChannelJoinRequest(Bytes1)
end,
{{channelJoinRequest,Val},NewBytes};
15 ->
{Val,NewBytes} = begin
dec_ChannelJoinConfirm(Bytes1)
end,
{{channelJoinConfirm,Val},NewBytes};
16 ->
{Val,NewBytes} = begin
dec_ChannelLeaveRequest(Bytes1)
end,
{{channelLeaveRequest,Val},NewBytes};
17 ->
{Val,NewBytes} = begin
dec_ChannelConveneRequest(Bytes1)
end,
{{channelConveneRequest,Val},NewBytes};
18 ->
{Val,NewBytes} = begin
dec_ChannelConveneConfirm(Bytes1)
end,
{{channelConveneConfirm,Val},NewBytes};
19 ->
{Val,NewBytes} = begin
dec_ChannelDisbandRequest(Bytes1)
end,
{{channelDisbandRequest,Val},NewBytes};
20 ->
{Val,NewBytes} = begin
dec_ChannelDisbandIndication(Bytes1)
end,
{{channelDisbandIndication,Val},NewBytes};
21 ->
{Val,NewBytes} = begin
dec_ChannelAdmitRequest(Bytes1)
end,
{{channelAdmitRequest,Val},NewBytes};
22 ->
{Val,NewBytes} = begin
dec_ChannelAdmitIndication(Bytes1)
end,
{{channelAdmitIndication,Val},NewBytes};
23 ->
{Val,NewBytes} = begin
dec_ChannelExpelRequest(Bytes1)
end,
{{channelExpelRequest,Val},NewBytes};
24 ->
{Val,NewBytes} = begin
dec_ChannelExpelIndication(Bytes1)
end,
{{channelExpelIndication,Val},NewBytes};
25 ->
{Val,NewBytes} = begin
dec_SendDataRequest(Bytes1)
end,
{{sendDataRequest,Val},NewBytes};
26 ->
{Val,NewBytes} = begin
dec_SendDataIndication(Bytes1)
end,
{{sendDataIndication,Val},NewBytes};
27 ->
{Val,NewBytes} = begin
dec_UniformSendDataRequest(Bytes1)
end,
{{uniformSendDataRequest,Val},NewBytes};
28 ->
{Val,NewBytes} = begin
dec_UniformSendDataIndication(Bytes1)
end,
{{uniformSendDataIndication,Val},NewBytes};
29 ->
{Val,NewBytes} = begin
dec_TokenGrabRequest(Bytes1)
end,
{{tokenGrabRequest,Val},NewBytes};
30 ->
{Val,NewBytes} = begin
dec_TokenGrabConfirm(Bytes1)
end,
{{tokenGrabConfirm,Val},NewBytes};
31 ->
{Val,NewBytes} = begin
dec_TokenInhibitRequest(Bytes1)
end,
{{tokenInhibitRequest,Val},NewBytes};
32 ->
{Val,NewBytes} = begin
dec_TokenInhibitConfirm(Bytes1)
end,
{{tokenInhibitConfirm,Val},NewBytes};
33 ->
{Val,NewBytes} = begin
dec_TokenGiveRequest(Bytes1)
end,
{{tokenGiveRequest,Val},NewBytes};
34 ->
{Val,NewBytes} = begin
dec_TokenGiveIndication(Bytes1)
end,
{{tokenGiveIndication,Val},NewBytes};
35 ->
{Val,NewBytes} = begin
dec_TokenGiveResponse(Bytes1)
end,
{{tokenGiveResponse,Val},NewBytes};
36 ->
{Val,NewBytes} = begin
dec_TokenGiveConfirm(Bytes1)
end,
{{tokenGiveConfirm,Val},NewBytes};
37 ->
{Val,NewBytes} = begin
dec_TokenPleaseRequest(Bytes1)
end,
{{tokenPleaseRequest,Val},NewBytes};
38 ->
{Val,NewBytes} = begin
dec_TokenPleaseIndication(Bytes1)
end,
{{tokenPleaseIndication,Val},NewBytes};
39 ->
{Val,NewBytes} = begin
dec_TokenReleaseRequest(Bytes1)
end,
{{tokenReleaseRequest,Val},NewBytes};
40 ->
{Val,NewBytes} = begin
dec_TokenReleaseConfirm(Bytes1)
end,
{{tokenReleaseConfirm,Val},NewBytes};
41 ->
{Val,NewBytes} = begin
dec_TokenTestRequest(Bytes1)
end,
{{tokenTestRequest,Val},NewBytes};
42 ->
{Val,NewBytes} = begin
dec_TokenTestConfirm(Bytes1)
end,
{{tokenTestConfirm,Val},NewBytes}
end.

%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    complete(element(1, Arg)),
    ok.

bit_string_name2pos_1(['begin' | T]) ->
    [0 | bit_string_name2pos_1(T)];
bit_string_name2pos_1(['end' | T]) ->
    [1 | bit_string_name2pos_1(T)];
bit_string_name2pos_1([{bit, Pos} | T]) when is_integer(Pos) ->
    [Pos | bit_string_name2pos_1(T)];
bit_string_name2pos_1([]) ->
    [];
bit_string_name2pos_1(_) ->
    throw(invalid).

dec_components10(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components10(Num, Bytes, Acc) ->
{Term,Remain} = dec_TokenAttributes(Bytes),
dec_components10(Num-1, Remain, [Term|Acc]).

dec_components11(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components11(Num, Bytes, Acc) ->
{Term,Remain} = begin
V1@Pad2 = bit_size(Bytes) band 7,
<<_:V1@Pad2,V1@V0:2/unsigned-unit:8,V1@Buf1/bitstring>> = Bytes,
V1@Add4 = V1@V0 + 1,
{V1@Add4,V1@Buf1}
end,
dec_components11(Num-1, Remain, [Term|Acc]).

dec_components12(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components12(Num, Bytes, Acc) ->
{Term,Remain} = dec_TokenAttributes(Bytes),
dec_components12(Num-1, Remain, [Term|Acc]).

dec_components13(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components13(Num, Bytes, Acc) ->
{Term,Remain} = begin
V2@Pad2 = bit_size(Bytes) band 7,
<<_:V2@Pad2,V2@V0:2/unsigned-unit:8,V2@Buf1/bitstring>> = Bytes,
V2@Add4 = V2@V0 + 1,
{V2@Add4,V2@Buf1}
end,
dec_components13(Num-1, Remain, [Term|Acc]).

dec_components14(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components14(Num, Bytes, Acc) ->
{Term,Remain} = begin
V3@Pad2 = bit_size(Bytes) band 7,
<<_:V3@Pad2,V3@V0:2/unsigned-unit:8,V3@Buf1/bitstring>> = Bytes,
V3@Add4 = V3@V0 + 1,
{V3@Add4,V3@Buf1}
end,
dec_components14(Num-1, Remain, [Term|Acc]).

dec_components15(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components15(Num, Bytes, Acc) ->
{Term,Remain} = begin
V4@Pad2 = bit_size(Bytes) band 7,
<<_:V4@Pad2,V4@V0:2/unsigned-unit:8,V4@Buf1/bitstring>> = Bytes,
{V4@V0,V4@Buf1}
end,
dec_components15(Num-1, Remain, [Term|Acc]).

dec_components16(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components16(Num, Bytes, Acc) ->
{Term,Remain} = begin
V5@Pad2 = bit_size(Bytes) band 7,
<<_:V5@Pad2,V5@V0:2/unsigned-unit:8,V5@Buf1/bitstring>> = Bytes,
{V5@V0,V5@Buf1}
end,
dec_components16(Num-1, Remain, [Term|Acc]).

dec_components17(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components17(Num, Bytes, Acc) ->
{Term,Remain} = begin
V6@Pad2 = bit_size(Bytes) band 7,
<<_:V6@Pad2,V6@V0:2/unsigned-unit:8,V6@Buf1/bitstring>> = Bytes,
{V6@V0,V6@Buf1}
end,
dec_components17(Num-1, Remain, [Term|Acc]).

dec_components18(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components18(Num, Bytes, Acc) ->
{Term,Remain} = begin
V7@Pad2 = bit_size(Bytes) band 7,
<<_:V7@Pad2,V7@V0:2/unsigned-unit:8,V7@Buf1/bitstring>> = Bytes,
{V7@V0,V7@Buf1}
end,
dec_components18(Num-1, Remain, [Term|Acc]).

dec_components19(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components19(Num, Bytes, Acc) ->
{Term,Remain} = begin
V8@Pad2 = bit_size(Bytes) band 7,
<<_:V8@Pad2,V8@V0:2/unsigned-unit:8,V8@Buf1/bitstring>> = Bytes,
{V8@V0,V8@Buf1}
end,
dec_components19(Num-1, Remain, [Term|Acc]).

dec_components2(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components2(Num, Bytes, Acc) ->
{Term,Remain} = begin
V9@Pad2 = bit_size(Bytes) band 7,
<<_:V9@Pad2,V9@V0:2/unsigned-unit:8,V9@Buf1/bitstring>> = Bytes,
{V9@V0,V9@Buf1}
end,
dec_components2(Num-1, Remain, [Term|Acc]).

dec_components20(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components20(Num, Bytes, Acc) ->
{Term,Remain} = begin
V10@Pad2 = bit_size(Bytes) band 7,
<<_:V10@Pad2,V10@V0:2/unsigned-unit:8,V10@Buf1/bitstring>> = Bytes,
{V10@V0,V10@Buf1}
end,
dec_components20(Num-1, Remain, [Term|Acc]).

dec_components21(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components21(Num, Bytes, Acc) ->
{Term,Remain} = begin
V11@Pad2 = bit_size(Bytes) band 7,
<<_:V11@Pad2,V11@V0:2/unsigned-unit:8,V11@Buf1/bitstring>> = Bytes,
{V11@V0,V11@Buf1}
end,
dec_components21(Num-1, Remain, [Term|Acc]).

dec_components3(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components3(Num, Bytes, Acc) ->
{Term,Remain} = dec_ChannelAttributes(Bytes),
dec_components3(Num-1, Remain, [Term|Acc]).

dec_components4(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components4(Num, Bytes, Acc) ->
{Term,Remain} = begin
V12@Pad2 = bit_size(Bytes) band 7,
<<_:V12@Pad2,V12@V0:2/unsigned-unit:8,V12@Buf1/bitstring>> = Bytes,
{V12@V0,V12@Buf1}
end,
dec_components4(Num-1, Remain, [Term|Acc]).

dec_components5(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components5(Num, Bytes, Acc) ->
{Term,Remain} = dec_ChannelAttributes(Bytes),
dec_components5(Num-1, Remain, [Term|Acc]).

dec_components6(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components6(Num, Bytes, Acc) ->
{Term,Remain} = begin
V13@Pad2 = bit_size(Bytes) band 7,
<<_:V13@Pad2,V13@V0:2/unsigned-unit:8,V13@Buf1/bitstring>> = Bytes,
{V13@V0,V13@Buf1}
end,
dec_components6(Num-1, Remain, [Term|Acc]).

dec_components7(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components7(Num, Bytes, Acc) ->
{Term,Remain} = begin
V14@Pad2 = bit_size(Bytes) band 7,
<<_:V14@Pad2,V14@V0:2/unsigned-unit:8,V14@Buf1/bitstring>> = Bytes,
{V14@V0,V14@Buf1}
end,
dec_components7(Num-1, Remain, [Term|Acc]).

dec_components8(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components8(Num, Bytes, Acc) ->
{Term,Remain} = begin
V15@Pad2 = bit_size(Bytes) band 7,
<<_:V15@Pad2,V15@V0:2/unsigned-unit:8,V15@Buf1/bitstring>> = Bytes,
{V15@V0,V15@Buf1}
end,
dec_components8(Num-1, Remain, [Term|Acc]).

dec_components9(0, Bytes, Acc) ->
{lists:reverse(Acc),Bytes};
dec_components9(Num, Bytes, Acc) ->
{Term,Remain} = begin
V16@Pad2 = bit_size(Bytes) band 7,
<<_:V16@Pad2,V16@V0:2/unsigned-unit:8,V16@Buf1/bitstring>> = Bytes,
{V16@V0,V16@Buf1}
end,
dec_components9(Num-1, Remain, [Term|Acc]).

adjust_trailing_zeroes(Bs0, Lb) ->
    case bit_size(Bs0) of
        Sz when Sz < Lb ->
            <<Bs0:Sz/bits,0:(Lb - Sz)>>;
        Lb ->
            Bs0;
        _ ->
            <<_:Lb/bits,Tail/bits>> = Bs0,
            Sz = Lb + bit_size(bs_drop_trailing_zeroes(Tail)),
            <<Bs:Sz/bits,_/bits>> = Bs0,
            Bs
    end.

bitstring_from_positions(L0, Lb) ->
    L1 = lists:sort(L0),
    L = diff(L1, - 1, Lb - 1),
    << 
      <<B:(N + 0)>> ||
          {B, N} <- L
    >>.

bs_drop_trailing_zeroes(Bs) ->
    bs_drop_trailing_zeroes(Bs, bit_size(Bs)).

bs_drop_trailing_zeroes(Bs, 0) ->
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) when Sz0 < 8 ->
    <<Byte:Sz0>> = Bs0,
    Sz = Sz0 - ntz(Byte),
    <<Bs:Sz/bits,_/bits>> = Bs0,
    Bs;
bs_drop_trailing_zeroes(Bs0, Sz0) ->
    Sz1 = Sz0 - 8,
    <<Bs1:Sz1/bits,Byte:8>> = Bs0,
    case ntz(Byte) of
        8 ->
            bs_drop_trailing_zeroes(Bs1, Sz1);
        Ntz ->
            Sz = Sz0 - Ntz,
            <<Bs:Sz/bits,_:Ntz/bits>> = Bs0,
            Bs
    end.

complete(L0) ->
    L = complete(L0, []),
    case list_to_bitstring(L) of
        <<>> ->
            <<0>>;
        Bin ->
            Bin
    end.

complete([], Bits, []) ->
    case Bits band 7 of
        0 ->
            [];
        N ->
            [<<0:(8 - N)>>]
    end;
complete([], Bits, [H | More]) ->
    complete(H, Bits, More);
complete([align | T], Bits, More) ->
    case Bits band 7 of
        0 ->
            complete(T, More);
        1 ->
            [<<0:7>> | complete(T, More)];
        2 ->
            [<<0:6>> | complete(T, More)];
        3 ->
            [<<0:5>> | complete(T, More)];
        4 ->
            [<<0:4>> | complete(T, More)];
        5 ->
            [<<0:3>> | complete(T, More)];
        6 ->
            [<<0:2>> | complete(T, More)];
        7 ->
            [<<0:1>> | complete(T, More)]
    end;
complete([[] | T], Bits, More) ->
    complete(T, Bits, More);
complete([[_ | _] = H], Bits, More) ->
    complete(H, Bits, More);
complete([[_ | _] = H | T], Bits, More) ->
    complete(H, Bits, [T | More]);
complete([H | T], Bits, More) when is_integer(H); is_binary(H) ->
    [H | complete(T, Bits, More)];
complete([H | T], Bits, More) ->
    [H | complete(T, Bits + bit_size(H), More)];
complete(Bin, Bits, More) when is_binary(Bin) ->
    [Bin | complete([], Bits, More)];
complete(Bin, Bits, More) ->
    [Bin | complete([], Bits + bit_size(Bin), More)].

complete([], []) ->
    [];
complete([], [H | More]) ->
    complete(H, More);
complete([align | T], More) ->
    complete(T, More);
complete([[] | T], More) ->
    complete(T, More);
complete([[_ | _] = H], More) ->
    complete(H, More);
complete([[_ | _] = H | T], More) ->
    complete(H, [T | More]);
complete([H | T], More) when is_integer(H); is_binary(H) ->
    [H | complete(T, More)];
complete([H | T], More) ->
    [H | complete(T, bit_size(H), More)];
complete(Bin, More) when is_binary(Bin) ->
    [Bin | complete([], More)];
complete(Bin, More) ->
    [Bin | complete([], bit_size(Bin), More)].

decode_fragmented(SegSz0, Buf0, Unit) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Res:SegSz/bitstring,Buf/bitstring>> = Buf0,
    decode_fragmented_1(Buf, Unit, Res).

decode_fragmented_1(<<0:1,N:7,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,0:1,N:14,Buf0/bitstring>>, Unit, Res) ->
    Sz = N * Unit,
    <<S:Sz/bitstring,Buf/bitstring>> = Buf0,
    {<<Res/bitstring,S/bitstring>>, Buf};
decode_fragmented_1(<<1:1,1:1,SegSz0:6,Buf0/bitstring>>, Unit, Res0) ->
    SegSz = SegSz0 * Unit * 16384,
    <<Frag:SegSz/bitstring,Buf/bitstring>> = Buf0,
    Res = <<Res0/bitstring,Frag/bitstring>>,
    decode_fragmented_1(Buf, Unit, Res).

decode_named_bit_string(Val, NNL) ->
    Bits =
        [ 
         B ||
             <<B:1>> <= Val
        ],
    decode_named_bit_string_1(0, Bits, NNL, []).

decode_named_bit_string_1(Pos, [0 | Bt], Names, Acc) ->
    decode_named_bit_string_1(Pos + 1, Bt, Names, Acc);
decode_named_bit_string_1(Pos, [1 | Bt], Names, Acc) ->
    case lists:keyfind(Pos, 2, Names) of
        {Name, _} ->
            decode_named_bit_string_1(Pos + 1, Bt, Names, [Name | Acc]);
        false ->
            decode_named_bit_string_1(Pos + 1,
                                      Bt, Names,
                                      [{bit, Pos} | Acc])
    end;
decode_named_bit_string_1(_Pos, [], _Names, Acc) ->
    lists:reverse(Acc).

diff([H | T], Prev, Last) ->
    [{1, H - Prev} | diff(T, H, Last)];
diff([], Prev, Last) when Last >= Prev ->
    [{0, Last - Prev}];
diff([], _, _) ->
    [].

encode_fragmented(Bin, Unit) ->
    encode_fragmented_1(Bin, Unit, 4).

encode_fragmented_1(Bin, Unit, N) ->
    SegSz = Unit * N * 16384,
    case Bin of
        <<B:SegSz/bitstring,T/bitstring>> ->
            [<<3:2,N:6>>, B | encode_fragmented_1(T, Unit, N)];
        _ when N > 1 ->
            encode_fragmented_1(Bin, Unit, N - 1);
        _ ->
            case bit_size(Bin) div Unit of
                Len when Len < 128 ->
                    [Len, Bin];
                Len when Len < 16384 ->
                    [<<2:2,Len:14>>, Bin]
            end
    end.

encode_unconstrained_number(Val) when not is_integer(Val) ->
    exit({error, {asn1, {illegal_integer, Val}}});
encode_unconstrained_number(Val) when Val >= 0 ->
    if
        Val < 128 ->
            [1, Val];
        Val < 256 ->
            [<<2,0>>, Val];
        true ->
            case binary:encode_unsigned(Val) of
                <<0:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) of
                        Sz when Sz < 128 ->
                            [Sz, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14>>, Bin]
                    end;
                <<1:1,_/bitstring>> = Bin ->
                    case byte_size(Bin) + 1 of
                        Sz when Sz < 128 ->
                            [Sz, 0, Bin];
                        Sz when Sz < 16384 ->
                            [<<2:2,Sz:14,0:8>>, Bin]
                    end
            end
    end;
encode_unconstrained_number(Val) ->
    Oct = enint(Val, []),
    Len = length(Oct),
    if
        Len < 128 ->
            [Len | Oct];
        Len < 16384 ->
            [<<2:2,Len:14>> | Oct]
    end.

enint(- 1, [B1 | T]) when B1 > 127 ->
    [B1 | T];
enint(N, Acc) ->
    enint(N bsr 8, [N band 255 | Acc]).

ntz(Byte) ->
    T = {8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2,
         0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
         1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
         0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
         2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3,
         0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
         1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1,
         0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
         3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
         0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
         1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1,
         0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
         2, 0, 1, 0},
    element(Byte + 1, T).
